<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <title>NFT Mint - Toy3Test</title>
  <!-- å¼•å…¥ ethers.js åº“ï¼ˆç”¨äºä¸ä»¥å¤ªåŠåˆçº¦äº¤äº’ï¼‰ -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js" type="application/javascript"></script>
  <script src="config.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    button { font-size: 16px; padding: 10px; margin-top: 5px; }
    #account { margin-top: 20px; font-weight: bold; }
    .mint-section {
      margin-top: 30px;
      padding: 15px;
      border: 1px solid #ccc;
      border-radius: 5px;
      width: 100%;
      box-sizing: border-box;
      margin-left: auto;
      margin-right: auto;
    }
    .mint-section input { width: 60px; padding: 6px; font-size: 14px; }
    .mint-section label { font-weight: bold; }
    #mintStatus { margin-top: 15px; color: #1a73e8; }
    .admin-section {
      margin-top: 30px;
      padding: 15px;
      border: 1px solid #f90;
      border-radius: 5px;
      width: 100%; 
      box-sizing: border-box;
      background: #fffbe6;
      margin-left: auto;
      margin-right: auto;
    }
    #adminStatus { margin-top: 10px; color: #d35400; }
  </style>
</head>
<body>
  <h1>NFT Mint Demo</h1>
    
  <button id="connectBtn">Connect Wallet</button>
    <div id="account"></div>

  <!-- ç®¡ç†å‘˜æ§åˆ¶mintå¼€å…³åŒºï¼ˆä»…åˆçº¦Ownerå¯è§ï¼‰ -->
  <div class="admin-section" id="adminSection" style="display:none;">
    <label>Mint Toggle:</label>
    <button id="toggleSaleBtn">Loading...</button>
    <div id="adminStatus"></div>
    <hr style="margin:16px 0;">
    <div>
      <label for="baseURIInput">Base URI (for unrevealed metadata):</label><br>
      <input type="text" id="baseURIInput" placeholder="ipfs://cid_for_unrevealed/">
      <button id="setBaseURIBtn">Set Base URI</button>
    </div>
    <div style="margin-top: 15px;">
      <label for="ipfsBaseURIInput">IPFS Base URI (for revealed metadata):</label><br>
      <input type="text" id="ipfsBaseURIInput" placeholder="ipfs://cid_for_revealed/">
      <button id="setIpfsBaseURIBtn">Set IPFS Base URI</button>
    </div>
    <div style="margin-top: 15px;">
      <label for="specialURIInput">Special URI (for special NFTs):</label><br>
      <input type="text" id="specialURIInput" placeholder="ipfs://cid_for_special/special.json">
      <button id="setSpecialURIBtn">Set Special URI</button>
      <span id="specialURIStatus"></span>
    </div>
    <div style="margin-top: 15px;">
      <label>Reward URIs (for reward NFTs, 3 types):</label><br>
      <input type="text" id="rewardURIInput0" placeholder="ipfs://cid_for_reward/reward0.json" style="width:320px;">
      <button id="setRewardURIBtn0">Set Reward URI 0</button>
      <span id="rewardURIStatus0"></span><br>
      <input type="text" id="rewardURIInput1" placeholder="ipfs://cid_for_reward/reward1.json" style="width:320px; margin-top:5px;">
      <button id="setRewardURIBtn1">Set Reward URI 1</button>
      <span id="rewardURIStatus1"></span><br>
      <input type="text" id="rewardURIInput2" placeholder="ipfs://cid_for_reward/reward2.json" style="width:320px; margin-top:5px;">
      <button id="setRewardURIBtn2">Set Reward URI 2</button>
      <span id="rewardURIStatus2"></span>
    </div>
    <div id="ownerStatus" style="margin-top: 10px;"></div>
    <div id="batchBurnResetCount" style="margin-top:10px;color:#1976d2;font-weight:bold;"></div>
    <hr style="margin:16px 0;">
    <div>
      <label for="batchBurnThresholdInput">Batch Burn æœ€ä½æ•°é‡ï¼š</label>
      <input type="number" id="batchBurnThresholdInput" min="1" value="10" style="width:80px;">
      <button id="setBatchBurnThresholdBtn">è®¾ç½®</button>
      <span id="batchBurnThresholdStatus" style="margin-left:10px;color:#d35400;"></span>
      <span id="currentBatchBurnThreshold" style="margin-left:10px;color:#4CAF50;font-weight:bold;"></span>
    </div>
    <hr style="margin:16px 0;">
    <div>
      <label for="specialMintCount">Special Mint æ•°é‡ï¼š</label>
      <input type="number" id="specialMintCount" min="1" value="1" style="width:80px;">
      <label for="specialMintTo">æ¥æ”¶åœ°å€ï¼š</label>
      <input type="text" id="specialMintTo" style="width:260px;" placeholder="é»˜è®¤è‡ªå·±åœ°å€">
      <button id="specialMintBtn">Special Mint</button>
      <span id="specialMintStatus"></span>
      </div>
    <hr style="margin:16px 0;">
    <div>
      <h3>ğŸ’° åˆçº¦èµ„é‡‘ç®¡ç†</h3>
      <div style="margin-bottom: 10px;">
        <strong>åˆçº¦ä½™é¢ï¼š</strong><span id="contractBalance">åŠ è½½ä¸­...</span>
        <button id="refreshBalanceBtn" style="margin-left: 10px; background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">åˆ·æ–°</button>
      </div>
      <button id="withdrawBtn" style="background: #FF00F9; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">æå–æ‰€æœ‰èµ„é‡‘</button>
      <div id="withdrawStatus" style="margin-top: 10px;"></div>
    </div>
    <hr style="margin:16px 0;">
    <div>
      <label for="mintPriceInput">Mint Price (ETH):</label>
      <input type="number" id="mintPriceInput" min="0" step="0.0001" style="width:100px;">
      <button id="setMintPriceBtn">Set Mint Price</button>
      <span id="mintPriceStatus" style="margin-left:10px;color:#4CAF50;font-weight:bold;"></span>
      <span id="currentMintPrice" style="margin-left:10px;color:#333;font-weight:bold;"></span>
    </div>
  </div>

  <!-- Mint NFT åŠŸèƒ½åŒº -->
  <div class="mint-section">
    <label for="mintCount">Mint Amount (max 10 per time, unlimited per wallet):</label><br>
    <input type="number" id="mintCount" min="1" max="10" value="1">
    <button id="mintBtn">Mint</button>
    <div id="mintStatus"></div>
  </div>

  <!-- æˆ‘çš„NFTæŸ¥çœ‹å’ŒRevealåŠŸèƒ½åŒº -->
  <div class="mint-section" id="myNFTSection" style="margin-top:40px;">
    <h2>My NFTs</h2>
    <button id="refreshNFTBtn" style="margin-bottom:10px;">Refresh</button>
    <button id="batchRevealBtn" style="margin-bottom:10px; margin-left:10px; background:#2196f3;color:white;">Batch Reveal</button>
    <button id="batchBurnBtn" style="margin-bottom:10px; margin-left:10px; background:#f44336;color:white;">Batch Burn</button>
    <div id="nftList">Loading...</div>
  </div>

  <script>
    // ===================== å˜é‡å’ŒDOMå…ƒç´ è·å– =====================
    const mintBtn = document.getElementById('mintBtn');       // Mint æŒ‰é’®
    const mintCountInput = document.getElementById('mintCount'); // Mint æ•°é‡è¾“å…¥æ¡†
    const mintStatus = document.getElementById('mintStatus'); // çŠ¶æ€æç¤º
    const adminSection = document.getElementById('adminSection'); // ç®¡ç†å‘˜åŒº
    const toggleSaleBtn = document.getElementById('toggleSaleBtn'); // å¼€å…³æŒ‰é’®
    const adminStatus = document.getElementById('adminStatus'); // ç®¡ç†å‘˜çŠ¶æ€
    const nftListDiv = document.getElementById('nftList');
    const refreshNFTBtn = document.getElementById('refreshNFTBtn');
    const batchBurnBtn = document.getElementById('batchBurnBtn');
    const batchBurnThresholdInput = document.getElementById('batchBurnThresholdInput');
    const setBatchBurnThresholdBtn = document.getElementById('setBatchBurnThresholdBtn');
    const batchBurnThresholdStatus = document.getElementById('batchBurnThresholdStatus');
    const batchRevealBtn = document.getElementById('batchRevealBtn');
    const specialMintCount = document.getElementById('specialMintCount');
    const specialMintTo = document.getElementById('specialMintTo');
    const specialMintBtn = document.getElementById('specialMintBtn');
    const specialMintStatus = document.getElementById('specialMintStatus');
    const connectBtn = document.getElementById('connectBtn');
    const accountDiv = document.getElementById('account');
    const baseURIInput = document.getElementById('baseURIInput');
    const setBaseURIBtn = document.getElementById('setBaseURIBtn');
    const ipfsBaseURIInput = document.getElementById('ipfsBaseURIInput');
    const setIpfsBaseURIBtn = document.getElementById('setIpfsBaseURIBtn');
    const ownerStatus = document.getElementById('ownerStatus');
    const specialURIInput = document.getElementById('specialURIInput');
    const setSpecialURIBtn = document.getElementById('setSpecialURIBtn');
    const specialURIStatus = document.getElementById('specialURIStatus');
    const mintPriceInput = document.getElementById('mintPriceInput');
    const setMintPriceBtn = document.getElementById('setMintPriceBtn');
    const mintPriceStatus = document.getElementById('mintPriceStatus');
    const currentMintPrice = document.getElementById('currentMintPrice');

    let userAccount = null; // å½“å‰ç”¨æˆ·é’±åŒ…åœ°å€
    let provider = null;    // ethers.js provider
    let signer = null;      // ethers.js signer
    let contract = null;    // åˆçº¦å®ä¾‹
    let isOwner = false;    // æ˜¯å¦ä¸ºåˆçº¦Owner
    let saleIsActive = false; // mintæ˜¯å¦å¼€å¯
    let defaultBaseURIOnChain = null; // æ–°å¢ï¼šé“¾ä¸Šæœªæ­ç¤ºmetadataé“¾æ¥
    let selectedNFTs = new Set();

    // ===================== åˆçº¦åœ°å€å’ŒABI =====================
    const contractAddress = CONFIG.contractAddress; // éƒ¨ç½²åœ¨Sepoliaçš„åˆçº¦åœ°å€
    const contractABI = [
      // Functions for minting and sale toggle
      "function mint(uint256 count) public payable",
      "function saleIsActive() public view returns (bool)",
      "function setSaleIsActive(bool saleIsActive_) external",
      "function owner() public view returns (address)",
      "function PRICE() public view returns (uint256)",
      "function MAX_SUPPLY() public view returns (uint256)",
      "function totalSupply() public view returns (uint256)",

      // Functions for NFT viewing/revealing
      "function balanceOf(address owner) public view returns (uint256)",
      "function tokenURI(uint256 tokenId) public view returns (string)",
      "function ownerOf(uint256 tokenId) public view returns (address)",
      "function reveal(uint256 tokenId) public",
      "function burn(uint256 tokenId) public",
      "function burnBatch(uint256[] tokenIds) external",
      "function defaultBaseURI() public view returns (string)",

      // Event for finding tokens
      "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)",

      // New functions for owner
        "function setBaseURI(string calldata defaultBaseURI_) external",
        "function setIpfsBaseURI(string calldata ipfsBaseURI_) external",
      "function setSpecialURI(string calldata specialURI_) external",
      "function ownerMintSpecial(uint256 count, address to) external",
      "function revealBatch(uint256[] tokenIds) external",
      "function specialBurn(uint256 tokenId) external",
      "function setBatchBurnThreshold(uint256 newThreshold) external",
      "function setPrice(uint256 newPrice) external",
      
      // Withdraw function
      "function withdraw() external",

      // Reward URI functions
      "function setRewardURI(uint8 idx, string uri) external",
      "function rewardURIs(uint256) public view returns (string)",
      "function userBatchBurnResetCount(address) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
    ];

    // ===================== é¡µé¢åŠ è½½åè‡ªåŠ¨è¿æ¥é’±åŒ… =====================
    window.onload = async function() {
      if (typeof window.ethereum === 'undefined') {
        alert('Please install MetaMask wallet extension');
        return;
      }
      try {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        const accounts = await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAccount = await signer.getAddress();
        contract = new ethers.Contract(contractAddress, contractABI, signer);
        // æ£€æŸ¥æ˜¯å¦ä¸ºOwner
        const ownerAddr = await contract.owner();
        if (userAccount.toLowerCase() === ownerAddr.toLowerCase()) {
          isOwner = true;
          adminSection.style.display = 'block';
          updateSaleStatus();
        }
        saleIsActive = await contract.saleIsActive();
        updateMintUI();
        defaultBaseURIOnChain = await contract.defaultBaseURI();
        setTimeout(loadMyNFTs, 1000);
        if (isOwner) {
          // æŸ¥è¯¢å½“å‰é˜ˆå€¼
          try {
            const threshold = await contract.batchBurnThreshold();
            batchBurnThresholdInput.value = threshold.toString();
            batchBurnThresholdStatus.innerText = `å½“å‰é˜ˆå€¼: ${threshold}`;
            document.getElementById('currentBatchBurnThreshold').innerText = `å½“å‰é˜ˆå€¼: ${threshold}`;
          } catch (e) {
            console.log('è·å–æ‰¹é‡ç‡ƒçƒ§é˜ˆå€¼å¤±è´¥:', e);
          }
          // åŠ è½½åˆçº¦ä½™é¢
          loadContractBalance();
        }
        await refreshMintPrice();
        await updateBatchBurnResetCount();
      } catch (err) {
        console.error('Wallet connection failed:', err);
        // no alert
      }
    };

    // ===================== ç®¡ç†å‘˜å¼€å…³é€»è¾‘ =====================
    async function updateSaleStatus() {
      saleIsActive = await contract.saleIsActive();
      toggleSaleBtn.innerText = saleIsActive ? 'Stop Mint' : 'Start Mint';
      adminStatus.innerText = 'Statusï¼š' + (saleIsActive ? 'Mint Started' : 'Mint Closed');
    }

    toggleSaleBtn.onclick = async function() {
      if (!isOwner) return;
      toggleSaleBtn.disabled = true;
      adminStatus.innerText = 'sending tx...';
      try {
        const tx = await contract.setSaleIsActive(!saleIsActive);
        await tx.wait();
        adminStatus.innerText = 'Mint status updatedï¼Tx: ' + tx.hash;
        updateSaleStatus();
        updateMintUI();
      } catch (err) {
        console.error(err);
        adminStatus.innerText = 'Mint Status update failed';
      }
      toggleSaleBtn.disabled = false;
    };

    // ===================== Mint æŒ‰é’®é€»è¾‘ =====================
    function updateMintUI() {
      mintBtn.disabled = !saleIsActive;
      mintStatus.innerText = saleIsActive ? '' : 'Mint not started yet';
    }

    mintBtn.onclick = async function() {
      if (!contract || !userAccount) {
        alert('connect wallet first');
        return;
      }
      const count = parseInt(mintCountInput.value);
      if (isNaN(count) || count < 1 || count > 10) {
        alert('Mint amount 1~10');
        return;
      }
      try {
        // æ£€æŸ¥mintå¼€å…³
        saleIsActive = await contract.saleIsActive();
        if (!saleIsActive) {
          mintStatus.innerText = 'Mint not started yet.';
          return;
        }
        // æ£€æŸ¥æ€»é‡
        const total = await contract.totalSupply();
        const max = await contract.MAX_SUPPLY();
        if (total.add(count).gt(max)) {
          mintStatus.innerText = 'Exceeding maximum supply';
          return;
        }
        // è·å–å•ä»·
        const price = await contract.PRICE();
        const totalValue = price.mul(count);
        mintStatus.innerText = 'Initiating mint transaction...';
        // å‘èµ·äº¤æ˜“
        const tx = await contract.mint(count, { value: totalValue });
        await tx.wait();
        mintStatus.innerText = `Mint successfulï¼Tx: ${tx.hash}`;
        setTimeout(loadMyNFTs, 2000);
      } catch (err) {
        console.error(err);
        if (err && err.data && err.data.message) {
          mintStatus.innerText = 'Mint failed: ' + err.data.message;
        } else if (err && err.message) {
          mintStatus.innerText = 'Mint failed: ' + err.message;
        } else {
          mintStatus.innerText = 'Mint failed';
        }
      }
    };

    // ===================== æ–°å¢ï¼šæˆ‘çš„NFTæŸ¥çœ‹å’ŒRevealåŠŸèƒ½ï¼ˆå·²ä¿®å¤ï¼‰ =====================
    // ä½¿ç”¨tokenOfOwnerByIndexä¼˜åŒ–åŠ è½½
    async function loadMyNFTs() {
      if (!contract || !userAccount) {
        nftListDiv.innerText = 'Please connect your wallet first';
        return;
      }
      selectedNFTs.clear();
      try {
        nftListDiv.innerHTML = '<h4>Loading your NFTs...</h4>';
        const balance = await contract.balanceOf(userAccount);
        if (balance.eq(0)) {
          nftListDiv.innerText = 'You do not own any NFTs.';
          return;
        }
        let html = '';
        let ownedCount = 0;
        for (let i = 0; i < balance; i++) {
          try {
            const tokenId = await contract.tokenOfOwnerByIndex(userAccount, i);
            let tokenURI = '';
            let revealed = false;
            let type = 'revealed';
            try {
              tokenURI = await contract.tokenURI(tokenId);
              function normalizeUrl(url) {
                return url ? url.replace(/\/+$/, '') : '';
              }
              if (tokenURI && tokenURI.includes('unrevealed.json')) {
                type = 'unreveal';
              } else if (tokenURI && tokenURI.includes('special.json')) {
                type = 'special';
              } else if (tokenId >= 20000) {
                type = 'reward';
              } // else é»˜è®¤æ˜¯revealed
            } catch (e) {
              console.error(`Failed to get TokenURI for tokenId: ${tokenId}`, e);
            }
            html += `<div style='margin-bottom:18px;padding:10px;border:1px solid #eee;display:inline-block;width:150px;vertical-align:top;position:relative;'>`;
            html += `<input type='checkbox' class='nft-checkbox' data-tokenid='${tokenId}' data-type='${type}' style='position:absolute;left:5px;top:5px;z-index:2;' />`;
            html += `<b>Token ID: ${tokenId}</b><br/>`;
            if (tokenURI) {
              const metadataUrl = tokenURI.startsWith('ipfs://') 
                ? tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/') 
                : tokenURI;
              try {
                const response = await fetch(metadataUrl);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const metadata = await response.json();
                if (metadata.image) {
                  const imageUrl = metadata.image.startsWith('ipfs://') 
                    ? metadata.image.replace('ipfs://', 'https://ipfs.io/ipfs/') 
                    : metadata.image;
                  html += `<img src='${imageUrl}' alt='NFT ${tokenId}' style='width:120px;height:120px;object-fit:cover;margin:8px 0;'/>`;
                } else {
                  html += `<div style='color:#999;font-size:12px;height:120px;display:flex;align-items:center;'>Image not found</div>`;
                }
                html += `<div><b>Name:</b> ${metadata.name ? metadata.name : 'Not found'}</div>`;
                html += `<div style='font-size:12px;color:#555;'><b>Description:</b> ${metadata.description ? metadata.description : 'Not found'}</div>`;
                if (metadata.attributes && Array.isArray(metadata.attributes) && metadata.attributes.length > 0) {
                  html += `<div style='font-size:12px;'><b>Attributes:</b> `;
                  metadata.attributes.forEach(attr => {
                    html += `<span style='margin-right:8px;'>${attr.trait_type}: ${attr.value}</span>`;
                  });
                  html += `</div>`;
                } else {
                  html += `<div style='font-size:12px;'><b>Attributes:</b> Not found</div>`;
                }
              } catch(e) {
                html += `<div style="color:red;font-size:12px;height:120px;display:flex;align-items:center;">Failed to load metadata</div>`;
                html += `<div><b>Name:</b> Not found</div>`;
                html += `<div style='font-size:12px;color:#555;'><b>Description:</b> Not found</div>`;
                html += `<div style='font-size:12px;'><b>Attributes:</b> Not found</div>`;
                console.error(`Failed to fetch metadata from ${metadataUrl}`, e);
              }
            } else {
              html += `<div style=\"color:red;font-size:12px;height:120px;display:flex;align-items:center;\">Failed to get Token URI</div>`;
            }
            if (type === 'reward') {
              html += `<button onclick='burnNFT(${tokenId})'>Burn</button>`;
            } else if (type === 'special') {
              html += `<button onclick='specialBurn(${tokenId})'>Special Burn</button>`;
            } else if (type === 'unreveal') {
              html += `<button onclick='revealNFT(${tokenId})'>Reveal</button>`;
            } else {
              html += `<button onclick='burnNFT(${tokenId})'>Burn</button>`;
            }
            html += `</div>`;
            ownedCount++;
          } catch (e) {
            console.log(`Skipping token at index ${i} due to error:`, e);
          }
        }
        if (ownedCount === 0) {
          nftListDiv.innerText = 'You do not own any NFTs.';
        } else {
          nftListDiv.innerHTML = html;
          document.querySelectorAll('.nft-checkbox').forEach(cb => {
            cb.addEventListener('change', function() {
              const tid = this.getAttribute('data-tokenid');
              if (this.checked) {
                selectedNFTs.add(tid);
              } else {
                selectedNFTs.delete(tid);
              }
            });
          });
        }
      } catch (err) {
        console.error("Failed to load NFTs:", err);
        nftListDiv.innerText = 'Error loading NFTs, check console for details.';
      }
    }

    // ===================== æ–°å¢ï¼šBurn NFTåŠŸèƒ½ =====================
    window.burnNFT = async function(tokenId) {
        if (!contract) return;
        if (!confirm(`Are you sure you want to burn Token ID: ${tokenId}? This action is irreversible!`)) {
            return;
        }
        
        try {
            const button = event.target;
            button.innerText = '...';
            button.disabled = true;

            const tx = await contract.burn(tokenId);
            await tx.wait();
            alert(`Token ID: ${tokenId} burned successfully! Tx: ${tx.hash}`);
            loadMyNFTs(); // åˆ·æ–°NFTåˆ—è¡¨
        } catch (err) {
            console.error(err);
            alert(`Burn failed: ${err.message}`);
            loadMyNFTs(); // å³ä½¿å¤±è´¥ä¹Ÿåˆ·æ–°
        }
    }

    // Reveal æŒ‰é’®äº‹ä»¶
    window.revealNFT = async function(tokenId) {
      if (!contract) return;
      try {
        const button = event.target;
        button.innerText = '...';
        button.disabled = true;
        
        const tx = await contract.reveal(tokenId);
        await tx.wait();
        alert('Reveal successful! Tx: ' + tx.hash);
        loadMyNFTs(); // åˆ·æ–°
      } catch (err) {
        console.error(err);
        alert('Reveal failed: ' + (err && err.message ? err.message : 'Unknown error'));
        loadMyNFTs(); // å³ä½¿å¤±è´¥ä¹Ÿåˆ·æ–°ä¸€ä¸‹
      }
    }

    // åˆ·æ–°æŒ‰é’®äº‹ä»¶
    refreshNFTBtn.onclick = function() {
      loadMyNFTs();
    }

    // Batch Burn æŒ‰é’®äº‹ä»¶
    batchBurnBtn.onclick = async function() {
      if (!contract || !userAccount) return;
      if (selectedNFTs.size < 10) {
        alert('Please select at least 10 NFTs to batch burn.');
        return;
      }
      if (!confirm(`Are you sure you want to batch burn these ${selectedNFTs.size} NFTs? This action is irreversible!`)) {
        return;
      }
      try {
        const tokenIds = Array.from(selectedNFTs).map(x => ethers.BigNumber.from(x));
        const tx = await contract.burnBatch(tokenIds);
        await tx.wait();
        alert(`Batch burn successful! Tx: ${tx.hash}`);
        loadMyNFTs();
      } catch (err) {
        console.error(err);
        alert('Batch burn failed: ' + (err && err.message ? err.message : 'Unknown error'));
        loadMyNFTs();
      }
    };

    setBatchBurnThresholdBtn.onclick = async function() {
      if (!isOwner) return;
      const newVal = parseInt(batchBurnThresholdInput.value);
      if (isNaN(newVal) || newVal < 1) {
        batchBurnThresholdStatus.innerText = 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ­£æ•´æ•°';
        return;
      }
      setBatchBurnThresholdBtn.disabled = true;
      batchBurnThresholdStatus.innerText = 'è®¾ç½®ä¸­...';
      try {
        const tx = await contract.setBatchBurnThreshold(newVal);
        await tx.wait();
        batchBurnThresholdStatus.innerText = `è®¾ç½®æˆåŠŸï¼Œå½“å‰é˜ˆå€¼: ${newVal}`;
        document.getElementById('currentBatchBurnThreshold').innerText = `å½“å‰é˜ˆå€¼: ${newVal}`;
      } catch (e) {
        batchBurnThresholdStatus.innerText = 'è®¾ç½®å¤±è´¥: ' + (e && e.message ? e.message : 'æœªçŸ¥é”™è¯¯');
      }
      setBatchBurnThresholdBtn.disabled = false;
    };

    // Batch Reveal æŒ‰é’®äº‹ä»¶
    batchRevealBtn.onclick = async function() {
      if (!contract || !userAccount) return;
      // åªå…è®¸é€‰æ‹©æœªæ­ç¤ºNFT
      const unrevealedTokenIds = [];
      document.querySelectorAll('.nft-checkbox').forEach(cb => {
        if (cb.checked && cb.getAttribute('data-type') === 'unreveal') {
          unrevealedTokenIds.push(cb.getAttribute('data-tokenid'));
        }
      });
      if (unrevealedTokenIds.length === 0) {
        alert('è¯·è‡³å°‘å‹¾é€‰1ä¸ªæœªæ­ç¤ºNFT');
        return;
      }
      if (unrevealedTokenIds.length > 10) {
        alert('ä¸€æ¬¡æœ€å¤šæ‰¹é‡Reveal 10ä¸ªNFT');
        return;
      }
      if (!confirm(`ç¡®å®šè¦æ‰¹é‡Revealè¿™${unrevealedTokenIds.length}ä¸ªNFTå—ï¼Ÿ`)) {
        return;
      }
      batchRevealBtn.disabled = true;
      try {
        const tx = await contract.revealBatch(unrevealedTokenIds);
        await tx.wait();
        alert(`æ‰¹é‡RevealæˆåŠŸï¼Tx: ${tx.hash}`);
        loadMyNFTs();
      } catch (err) {
        console.error(err);
        alert('æ‰¹é‡Revealå¤±è´¥: ' + (err && err.message ? err.message : 'æœªçŸ¥é”™è¯¯'));
        loadMyNFTs();
      }
      batchRevealBtn.disabled = false;
    };

    specialMintBtn.onclick = async function() {
      if (!isOwner) return;
      const count = parseInt(specialMintCount.value);
      let to = specialMintTo.value.trim();
      if (!to) to = userAccount;
      if (isNaN(count) || count < 1) {
        specialMintStatus.innerText = 'è¯·è¾“å…¥æœ‰æ•ˆæ•°é‡';
        return;
      }
      specialMintBtn.disabled = true;
      specialMintStatus.innerText = 'mintä¸­...';
      try {
        const tx = await contract.ownerMintSpecial(count, to);
        await tx.wait();
        specialMintStatus.innerText = `Special MintæˆåŠŸï¼Tx: ${tx.hash}`;
        setTimeout(loadMyNFTs, 1000);
      } catch (e) {
        specialMintStatus.innerText = 'mintå¤±è´¥: ' + (e && e.message ? e.message : 'æœªçŸ¥é”™è¯¯');
      }
      specialMintBtn.disabled = false;
    };

    // æ–°å¢Special BurnåŠŸèƒ½
    window.specialBurn = async function(tokenId) {
      if (!contract) return;
      if (!confirm(`ç¡®å®šè¦Special Burnç‰¹æ®ŠNFT Token ID: ${tokenId}ï¼Ÿé”€æ¯åå°†å…è´¹è·å¾—2ä¸ªæ™®é€šNFTï¼`)) {
        return;
      }
      try {
        const button = event.target;
        button.innerText = '...';
        button.disabled = true;
        const tx = await contract.specialBurn(tokenId);
        await tx.wait();
        alert(`Special BurnæˆåŠŸï¼Tx: ${tx.hash}`);
        loadMyNFTs();
      } catch (err) {
        console.error(err);
        alert(`Special Burnå¤±è´¥: ${err && err.message ? err.message : 'æœªçŸ¥é”™è¯¯'}`);
        loadMyNFTs();
      }
    }

    connectBtn.onclick = async function() {
      if (typeof window.ethereum === 'undefined') {
        alert('è¯·å…ˆå®‰è£… MetaMask é’±åŒ…æ’ä»¶');
        return;
      }
      try {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        const accounts = await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAccount = await signer.getAddress();
        accountDiv.innerText = 'Connected: ' + userAccount;
        connectBtn.style.display = 'none';
        contract = new ethers.Contract(contractAddress, contractABI, signer);
        // æ£€æŸ¥æ˜¯å¦ä¸ºOwner
        const ownerAddr = await contract.owner();
        if (userAccount.toLowerCase() === ownerAddr.toLowerCase()) {
          isOwner = true;
          adminSection.style.display = 'block';
          updateSaleStatus();
        }
        saleIsActive = await contract.saleIsActive();
        updateMintUI();
        defaultBaseURIOnChain = await contract.defaultBaseURI();
        setTimeout(loadMyNFTs, 1000);
        // æŸ¥è¯¢owneråŒºå—å†…å®¹
        if (isOwner) {
          try {
            const threshold = await contract.batchBurnThreshold();
            batchBurnThresholdInput.value = threshold.toString();
            batchBurnThresholdStatus.innerText = `å½“å‰é˜ˆå€¼: ${threshold}`;
            document.getElementById('currentBatchBurnThreshold').innerText = `å½“å‰é˜ˆå€¼: ${threshold}`;
          } catch (e) {
            console.log('è·å–æ‰¹é‡ç‡ƒçƒ§é˜ˆå€¼å¤±è´¥:', e);
          }
          // åŠ è½½åˆçº¦ä½™é¢
          loadContractBalance();
        }
        await refreshMintPrice();
        await updateBatchBurnResetCount();
      } catch (err) {
        console.error('Connect wallet failed:', err);
        alert('User rejected connection request');
      }
    };

    setBaseURIBtn.onclick = async function() {
      const uri = baseURIInput.value;
      if (!uri) {
        alert("Please enter Base URI");
        return;
      }
      ownerStatus.innerText = "Setting Base URI...";
      try {
        const tx = await contract.setBaseURI(uri);
        await tx.wait();
        ownerStatus.innerText = `Base URI set successfully! Tx: ${tx.hash}`;
      } catch (error) {
        console.error(error);
        ownerStatus.innerText = "Failed to set Base URI.";
      }
    };

    setIpfsBaseURIBtn.onclick = async function() {
      const uri = ipfsBaseURIInput.value;
      if (!uri) {
        alert("Please enter IPFS Base URI");
        return;
      }
      ownerStatus.innerText = "Setting IPFS Base URI...";
      try {
        const tx = await contract.setIpfsBaseURI(uri);
        await tx.wait();
        ownerStatus.innerText = `IPFS Base URI set successfully! Tx: ${tx.hash}`;
      } catch (error) {
        console.error(error);
        ownerStatus.innerText = "Failed to set IPFS Base URI.";
      }
    };

    setSpecialURIBtn.onclick = async function() {
      const uri = specialURIInput.value;
      if (!uri) {
        alert("Please enter Special URI");
        return;
      }
      specialURIStatus.innerText = "Setting Special URI...";
      try {
        const tx = await contract.setSpecialURI(uri);
        await tx.wait();
        specialURIStatus.innerText = `Special URI set successfully! Tx: ${tx.hash}`;
      } catch (error) {
        console.error(error);
        specialURIStatus.innerText = "Failed to set Special URI.";
      }
    };

    // æ–°å¢åˆçº¦ä½™é¢å’Œææ¬¾åŠŸèƒ½
    async function loadContractBalance() {
      if (!contract || !userAccount) {
        document.getElementById('contractBalance').innerText = 'åŠ è½½åˆçº¦ä½™é¢å¤±è´¥ï¼Œè¯·å…ˆè¿æ¥é’±åŒ…';
        return;
      }
      try {
        const balance = await provider.getBalance(contractAddress);
        const balanceText = `${ethers.utils.formatEther(balance)} ETH`;
        document.getElementById('contractBalance').innerText = balanceText;
      } catch (err) {
        console.error('åŠ è½½åˆçº¦ä½™é¢å¤±è´¥:', err);
        document.getElementById('contractBalance').innerText = 'åŠ è½½åˆçº¦ä½™é¢å¤±è´¥';
      }
    }

    async function withdrawAllFunds() {
      if (!contract || !userAccount) {
        alert('è¯·å…ˆè¿æ¥é’±åŒ…');
        return;
      }
      if (!isOwner) {
        alert('åªæœ‰åˆçº¦æ‰€æœ‰è€…æ‰èƒ½æå–èµ„é‡‘');
        return;
      }
      if (!confirm('ç¡®å®šè¦æå–æ‰€æœ‰èµ„é‡‘å—ï¼Ÿæ­¤æ“ä½œæ˜¯ä¸å¯é€†çš„ï¼')) {
        return;
      }
      try {
        const withdrawStatus = document.getElementById('withdrawStatus');
        withdrawStatus.innerText = 'æ­£åœ¨æå–èµ„é‡‘...';
        const tx = await contract.withdraw();
        withdrawStatus.innerText = 'ç­‰å¾…äº¤æ˜“ç¡®è®¤...';
        await tx.wait();
        withdrawStatus.innerText = `âœ… æå–èµ„é‡‘æˆåŠŸï¼Tx: ${tx.hash}`;
        loadContractBalance(); // åˆ·æ–°ä½™é¢æ˜¾ç¤º
      } catch (err) {
        console.error('æå–èµ„é‡‘å¤±è´¥:', err);
        const withdrawStatus = document.getElementById('withdrawStatus');
        if (err && (err.code === 4001 || (err.message && err.message.toLowerCase().includes('user rejected')))) {
          withdrawStatus.innerText = 'âŒ ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“';
        } else {
          withdrawStatus.innerText = `âŒ æå–èµ„é‡‘å¤±è´¥: ${err.message}`;
        }
      }
    }

    document.getElementById('withdrawBtn').onclick = withdrawAllFunds;
    document.getElementById('refreshBalanceBtn').onclick = loadContractBalance;

    async function refreshMintPrice() {
      if (!contract) return;
      try {
        const price = await contract.PRICE();
        const ethPrice = ethers.utils.formatEther(price);
        currentMintPrice.innerText = `Current: ${ethPrice} ETH`;
        mintPriceInput.value = ethPrice;
      } catch (e) {
        currentMintPrice.innerText = 'Failed to fetch';
      }
    }

    setMintPriceBtn.onclick = async function() {
      if (!contract || !isOwner) {
        mintPriceStatus.innerText = 'Only owner can set price!';
        return;
      }
      const newPrice = mintPriceInput.value;
      if (!newPrice || isNaN(newPrice) || Number(newPrice) <= 0) {
        mintPriceStatus.innerText = 'Invalid price';
        return;
      }
      try {
        const tx = await contract.setPrice(ethers.utils.parseEther(newPrice));
        mintPriceStatus.innerText = 'Setting...';
        await tx.wait();
        mintPriceStatus.innerText = 'Success!';
        await refreshMintPrice();
      } catch (e) {
        mintPriceStatus.innerText = 'Failed to set price';
      }
    };

    // ===================== Reward URI è®¾ç½® =====================
    const rewardURIInputs = [
      document.getElementById('rewardURIInput0'),
      document.getElementById('rewardURIInput1'),
      document.getElementById('rewardURIInput2')
    ];
    const setRewardURIBtns = [
      document.getElementById('setRewardURIBtn0'),
      document.getElementById('setRewardURIBtn1'),
      document.getElementById('setRewardURIBtn2')
    ];
    const rewardURIStatus = [
      document.getElementById('rewardURIStatus0'),
      document.getElementById('rewardURIStatus1'),
      document.getElementById('rewardURIStatus2')
    ];
    for (let i = 0; i < 3; i++) {
      setRewardURIBtns[i].onclick = async function() {
        if (!isOwner) return;
        const uri = rewardURIInputs[i].value;
        if (!uri) {
          rewardURIStatus[i].innerText = 'Please enter Reward URI';
          return;
        }
        setRewardURIBtns[i].disabled = true;
        rewardURIStatus[i].innerText = 'Setting...';
        try {
          const tx = await contract.setRewardURI(i, uri);
          await tx.wait();
          rewardURIStatus[i].innerText = `Reward URI ${i} set successfully! Tx: ${tx.hash}`;
        } catch (e) {
          rewardURIStatus[i].innerText = 'Failed: ' + (e && e.message ? e.message : 'Unknown error');
        }
        setRewardURIBtns[i].disabled = false;
      };
    }

    async function updateBatchBurnResetCount() {
      if (!contract || !userAccount) return;
      try {
        const count = await contract.userBatchBurnResetCount(userAccount);
        document.getElementById('batchBurnResetCount').innerText = `Your BatchBurnAndReset Count: ${count}`;
      } catch (e) {
        document.getElementById('batchBurnResetCount').innerText = 'Failed to fetch batch burn count';
      }
    }
  </script>
</body>
</html> 
