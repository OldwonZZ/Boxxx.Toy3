<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <title>Toy3.BoXXX</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js" type="application/javascript"></script>
  <script src="config.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- 钱包连接区域 -->
  <div class="wallet-container">
    <div class="logo-container">
      <img src="toy3logo.png" alt="Logo" class="logo">
    </div>
    <div class="wallet-controls">
      <div id="walletInfo"></div>
      <button id="connectMetaMaskButton">Connect MetaMask</button>
    </div>
  </div>
 
  <div id="carouselArea">
    <div class="profile-header">
        <div class="selection-controls" id="selectionControls">
          <div class="selection-info" id="selectionInfo">
            <span class="selection-count" id="selectionCount">0 selected</span>
            <button class="unselect-all" id="unselectAllBtn">unselect all</button>
          </div>
          <div class="nft-counter" id="nftCounter">0 Box Collected</div>
        </div>
      </div>
    <div class="carousel-outer carousel-outer-custom">
      <button class="carousel-arrow left" id="leftArrow">&#9664;</button>
      <div class="carousel-container">
        <div class="carousel-track" id="carouselTrack"></div>
      </div>
      <button class="carousel-arrow right" id="rightArrow">&#9654;</button>
    </div>
    <div class="height-32"></div>
    <div id="refreshArea" class="refresh-area">
      <span id="refreshStatusText" class="refresh-status-text">&nbsp;</span>
      <span id="refreshText" class="refresh-text">Refresh</span>
      <button id="refreshBtn" class="refresh-btn">Load my collection</button>
      <div class="profile-actions profile-actions-hidden" id="batchActions">
        <button class="profile-btn batch-reveal-btn" id="batchRevealBtn">Batch Reveal</button>
        <button class="profile-btn batch-burn-btn" id="batchBurnBtn">
          ReBoXXX!
          <div class="info-icon">!</div>
          <div class="tooltip">Burn 6 cards to get a new BoXXX<br>Get 1 EPIC card every 3 times.</div>
        </button>
        <div id="batchBurnResetRuler" class="batch-burn-reset-ruler"></div>
      </div>
    </div>
    <!-- Mint Row from mint.html -->
    <div class="center-container center-container-custom">
      <div class="mint-row">
        <div class="mint-progress" id="mintProgress">--/888</div>
        <span id="burnedCountDisplay" class="burned-count-display"></span>
        <div class="mint-slider-container">
          <div class="slider-labels">
            <span>1</span>
            <span style="flex:1"></span>
            <span>10</span>
          </div>
          <div style="position:relative; width:260px; margin:0 auto;">
            <input type="range" min="1" max="10" value="10" id="mintSlider" class="mint-slider">
            <div id="sliderValueBox" class="slider-value-box">10</div>
          </div>
        </div>
        <div class="mint-btn-group">
          <button class="mint-btn" id="mintBtn"><span class="mint-label">MINT</span><span class="mint-price"><span class="eth-row" id="mintPriceEth">--<small>ETH</small></span><span class="perbox-row">Per Box</span></span></button>
        </div>
      </div>
      <div id="mintStatus"></div>
    </div>
  </div>

  <!-- 弹窗容器 -->
  <div id="modalContainer" class="modal-container-hidden"></div>
  <script>
    // 稀有度与颜色映射
    const RARITY_CLASS = {
      legendary: 'legendary',
      epic: 'epic',
      rare: 'rare',
      common: 'common'
    };
    const RARITY_LABEL = {
      legendary: 'LEGENDARY',
      epic: 'EPIC',
      rare: 'RARE',
      common: 'COMMON'
    };

    // ========== 合约与数据 =============
    const contractAddress = CONFIG.contractAddress;
    const contractABI = [
      "function balanceOf(address owner) public view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256)",
      "function tokenURI(uint256 tokenId) public view returns (string)",
      "function ownerOf(uint256 tokenId) public view returns (address)",
      "function reveal(uint256 tokenId) public",
      "function burn(uint256 tokenId) public",
      "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)",
      // 批量相关
      "function burnBatch(uint256[] tokenIds) external",
      "function revealBatch(uint256[] tokenIds) external",
      // 特殊NFT相关
      "function isSpecial(uint256 tokenId) public view returns (bool)",
      "function specialBurn(uint256 tokenId) external",
      "function specialURI() public view returns (string)",
      // === mint相关 ===
      "function mint(uint256 count) public payable",
      "function saleIsActive() public view returns (bool)",
      "function PRICE() public view returns (uint256)",
      "function MAX_SUPPLY() public view returns (uint256)",
      "function totalSupply() public view returns (uint256)",
      "function batchBurnAndReset(uint256[] calldata tokenIds) external",
      "function burnedCount() external view returns (uint256)",
      "function userBatchBurnResetCount(address user) external view returns (uint256)"
    ];

    // ========== 钱包与合约自动连接 =============
    let userAccount = null;
    let provider = null;
    let signer = null;
    let contract = null;
    let nfts = [];
    let current = 0;
    const MIN_CARDS = 5;
    const CARD_WIDTH = 280; // px, 与样式保持一致
    const CARD_GAP = 36; // px, 与样式保持一致
    let isLoadingNFTs = false;
    let isNFTsLoaded = false;
    const VISIBLE_COUNT = 5;
    let selectedTokenIds = new Set(); // 记录已选tokenId

    // ===================== 钱包连接状态管理 =====================
    // 使用配置文件中的网络设置
    const CHAIN_CONFIG = CONFIG.CHAIN_CONFIG;
    
    // 全局状态
    const walletState = {
        isConnected: false,
        account: null,
        chainId: null,
        isCorrectChain: false,
        listeners: []
    };

    // 合约相关变量
    let saleIsActive = false;

    // ===================== 钱包连接功能 =====================
    // 强制切换到Sepolia链
    async function forceSepoliaChain() {
        try {
            const currentChainId = await window.ethereum.request({ 
                method: 'eth_chainId' 
            });
            if (currentChainId !== CHAIN_CONFIG.chainId) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: CHAIN_CONFIG.chainId }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [CHAIN_CONFIG]
                        });
                    } else {
                        throw switchError;
                    }
                }
            }
            return true;
        } catch (error) {
            console.error('Chain switch failed:', error);
            throw error;
        }
    }

    // 检测MetaMask是否安装
    function checkMetaMask() {
        if (typeof window.ethereum === 'undefined') {
            throw new Error('MetaMask not detected');
        }
        if (!window.ethereum.isMetaMask) {
            throw new Error('Non-MetaMask provider detected');
        }
        return true;
    }

    // 连接钱包核心逻辑
    async function connectMetaMask() {
        try {
            checkMetaMask();
            await forceSepoliaChain();
            const accounts = await window.ethereum.request({ 
                method: 'eth_requestAccounts' 
            });
            if (accounts.length === 0) {
                throw new Error('No accounts returned');
            }
            const chainId = await window.ethereum.request({ 
                method: 'eth_chainId' 
            });
            
            // 设置钱包状态
            walletState.isConnected = true;
            walletState.account = accounts[0];
            walletState.chainId = chainId;
            walletState.isCorrectChain = chainId === CHAIN_CONFIG.chainId;
            
            // 初始化ethers.js
            provider = new ethers.providers.Web3Provider(window.ethereum);
            signer = provider.getSigner();
            contract = new ethers.Contract(contractAddress, contractABI, signer);
            
            // 设置全局变量
            userAccount = walletState.account;
            window.contract = contract;
            window.userAccount = userAccount;
            
            updateUI();
            setupEventListeners();
            await loadNFTs();
            renderCarousel();
            updateMintStatus();
            setRefreshLoadedUI(); // 新增：钱包连接后自动切换到已加载状态
            await updateBatchBurnResetRuler();
        } catch (error) {
            console.error('Connection failed:', error);
            showModal('Wallet connection failed. Please check your wallet and network.', {
                buttons: [{ text: 'OK', primary: true }]
            });
        }
    }

    // 事件监听设置
    function setupEventListeners() {
        if (!window.ethereum) return;
        removeAllListeners();
        const accountsChanged = (accounts) => {
            if (accounts.length === 0) {
                resetWalletState();
            } else {
                walletState.account = accounts[0];
                userAccount = walletState.account;
                window.userAccount = userAccount;
            }
            updateUI();
            loadNFTs().then(() => {
                renderCarousel();
                updateMintStatus();
            });
        };
        const chainChanged = (chainId) => {
            walletState.chainId = chainId;
            walletState.isCorrectChain = chainId === CHAIN_CONFIG.chainId;
            updateUI();
            updateMintStatus();
        };
        window.ethereum.on('accountsChanged', accountsChanged);
        window.ethereum.on('chainChanged', chainChanged);
        walletState.listeners = [
            { type: 'accountsChanged', handler: accountsChanged },
            { type: 'chainChanged', handler: chainChanged }
        ];
    }

    // 移除所有事件监听器
    function removeAllListeners() {
        if (!window.ethereum || !walletState.listeners.length) return;
        walletState.listeners.forEach(({ type, handler }) => {
            try {
                window.ethereum.removeListener(type, handler);
            } catch (error) {
                console.warn(`Failed to remove ${type} listener:`, error);
            }
        });
        walletState.listeners = [];
    }

    // UI更新函数
    function updateUI() {
        const infoEl = document.getElementById('walletInfo');
        const buttonEl = document.getElementById('connectMetaMaskButton');
        infoEl.className = '';
        if (walletState.isConnected) {
            const chainStatus = walletState.isCorrectChain ?
                '' : 
                `Wrong Chain (${formatChainId(walletState.chainId)})`;
            infoEl.textContent = `${formatAddress(walletState.account)}`;
            if (walletState.isCorrectChain) {
                infoEl.classList.add('connected');
            } else {
                infoEl.classList.add('wrong-chain');
            }
            buttonEl.textContent = 'Disconnect';
            buttonEl.classList.add('disconnect');
            buttonEl.onclick = disconnectWallet;
        } else {
            infoEl.textContent = 'Not connected';
            infoEl.classList.add('disconnected');
            buttonEl.textContent = 'Connect MetaMask';
            buttonEl.classList.remove('disconnect');
            buttonEl.onclick = connectMetaMask;
        }
    }

    // 辅助函数
    function formatAddress(address) {
        return address ? `${address.slice(0, 6)}...${address.slice(-4)}` : '';
    }
    function formatChainId(chainId) {
        return CONFIG.CHAIN_NAMES[chainId] || chainId;
    }
    function resetWalletState() {
        walletState.isConnected = false;
        walletState.account = null;
        walletState.chainId = null;
        walletState.isCorrectChain = false;
        provider = null;
        signer = null;
        contract = null;
        userAccount = null;
        window.contract = null;
        window.userAccount = null;
        nfts = [];
        isNFTsLoaded = false;
        mintPriceEth.innerHTML = '--<small>ETH</small>';
    }

    // 断开连接
    async function disconnectWallet() {
        try {
            await window.ethereum.request({
                method: 'wallet_revokePermissions',
                params: [{ eth_accounts: {} }]
            });
        } catch (error) {
            console.warn('Failed to revoke permissions:', error);
        }
        resetWalletState();
        updateUI();
        renderCarousel();
        updateMintStatus();
        // 新增：断开钱包后重置refresh按钮状态
        const status = document.getElementById('refreshStatusText');
        const refreshBtn = document.getElementById('refreshBtn');
        const refreshText = document.getElementById('refreshText');
        if (status) status.innerText = '';
        if (refreshBtn) refreshBtn.style.display = 'inline-block';
        if (refreshText) refreshText.style.display = 'none';
    }

    // 检查钱包连接状态
    async function checkWalletConnection() {
        if (typeof window.ethereum === 'undefined') {
            updateUI();
            return;
        }
        
        try {
            const accounts = await window.ethereum.request({ 
                method: 'eth_accounts' 
            });
            const chainId = await window.ethereum.request({ 
                method: 'eth_chainId' 
            });
            
            if (accounts.length > 0) {
                walletState.isConnected = true;
                walletState.account = accounts[0];
                walletState.chainId = chainId;
                walletState.isCorrectChain = chainId === CHAIN_CONFIG.chainId;
                
                // 初始化ethers.js
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                contract = new ethers.Contract(contractAddress, contractABI, signer);
                
                // 设置全局变量
                userAccount = walletState.account;
                window.contract = contract;
                window.userAccount = userAccount;
                
                setupEventListeners();
                // 新增：弹窗提示加载
                showModal('<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;">' +
                  '<div class="modal-spinner"></div>' +
                  '<div style="margin-top:8px;">Loading your collection...</div></div>');
                await loadNFTs();
                hideModal();
                renderCarousel();
                updateMintStatus();
                setRefreshLoadedUI();
                await updateBatchBurnResetRuler();
            }
        } catch (error) {
            console.error('Failed to check wallet connection:', error);
            hideModal();
        }
        updateUI();
    }

    window.onload = async function() {
        renderCarousel(); // 页面一加载就渲染 empty card
        await checkWalletConnection();
    };

    async function loadNFTs() {
      isNFTsLoaded = false;
      nfts = [];
      if (!contract || !userAccount) return;
      try {
        const balance = await contract.balanceOf(userAccount);
        if (balance.eq(0)) { isNFTsLoaded = true; return; }
        // 用ERC721Enumerable批量获取tokenId
        const ownedTokenIds = [];
        for (let i = 0; i < balance; i++) {
          const tokenId = await contract.tokenOfOwnerByIndex(userAccount, i);
          ownedTokenIds.push(tokenId.toString());
        }
        // 并行获取所有tokenURI
        const tokenURIPromises = ownedTokenIds.map(async (tokenId) => {
          try {
            const tokenURI = await contract.tokenURI(tokenId);
            return { tokenId, tokenURI };
          } catch (e) {
            console.error(`获取TokenURI失败 for tokenId: ${tokenId}`, e);
            return { tokenId, tokenURI: '' };
          }
        });
        const tokenURIs = await Promise.all(tokenURIPromises);
        // 并行获取所有metadata
        const metadataPromises = tokenURIs.map(async ({ tokenId, tokenURI }) => {
          let revealed = false, meta = {}, rarity = 'common', image = '', name = '', description = '', type = 'revealed', physical = false;
          if (tokenURI && tokenURI.includes('special.json')) {
            type = 'special';
            revealed = false;
          } else if (tokenURI && tokenURI.includes('unrevealed.json')) {
            type = 'unreveal';
            revealed = false;
          } else {
            type = 'revealed';
            revealed = true;
          }
          if (tokenURI) {
            const metadataUrl = tokenURI.startsWith('ipfs://') ? tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/') : tokenURI;
            try {
              const response = await fetch(metadataUrl);
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const metadata = await response.json();
              if (metadata.image) {
                image = metadata.image.startsWith('ipfs://') ? metadata.image.replace('ipfs://', 'https://ipfs.io/ipfs/') : metadata.image;
              }
              if (metadata.name) {
                name = metadata.name;
              }
              if (metadata.description) {
                description = metadata.description;
              }
              if (metadata.physical !== undefined) {
                physical = metadata.physical;
              }
              if (metadata.attributes && Array.isArray(metadata.attributes)) {
                const rarityAttr = metadata.attributes.find(a => a.trait_type && a.trait_type.toLowerCase() === 'rarity');
                if (rarityAttr && rarityAttr.value) {
                  const val = rarityAttr.value.toLowerCase();
                  if (RARITY_CLASS[val]) rarity = val;
                }
              }
            } catch(e) {
              console.error(`Failed to fetch metadata from ${metadataUrl}`, e);
            }
          }
          return { tokenId, revealed, image, name, description, rarity, type, physical };
        });
        nfts = await Promise.all(metadataPromises);
        isNFTsLoaded = true;
      } catch (err) {
        isNFTsLoaded = true;
        console.error("Failed to load NFTs:", err);
      }
    }

    // ========== 轮播渲染 =============
    function renderCarousel() {
      const track = document.getElementById('carouselTrack');
      let displayNFTs = [];
      if (!isNFTsLoaded) {
        for (let i = 0; i < MIN_CARDS; i++) displayNFTs.push({empty: true});
      } else {
        // 新增排序逻辑
        const rarityOrder = { legendary: 0, epic: 1, rare: 2, common: 3 };
        displayNFTs = nfts.slice().sort((a, b) => {
          // Special > unreveal > revealed
          const typeOrder = { special: 0, unreveal: 1, revealed: 2 };
          const aType = typeOrder[a.type] !== undefined ? typeOrder[a.type] : 3;
          const bType = typeOrder[b.type] !== undefined ? typeOrder[b.type] : 3;
          if (aType !== bType) return aType - bType;
          // revealed内部按稀有度排序
          if (aType === 2 && bType === 2) {
            const aRarity = rarityOrder[a.rarity] !== undefined ? rarityOrder[a.rarity] : 99;
            const bRarity = rarityOrder[b.rarity] !== undefined ? rarityOrder[b.rarity] : 99;
            if (aRarity !== bRarity) return aRarity - bRarity;
          }
          // 其他情况按tokenId升序
          return (a.tokenId || 0) - (b.tokenId || 0);
        });
        // 在最后一张NFT后面额外加两张空白卡片
        for (let i = 0; i < 2; i++) displayNFTs.push({empty: true});
        if (displayNFTs.length < MIN_CARDS) {
          for (let i = displayNFTs.length; i < MIN_CARDS; i++) {
            displayNFTs.push({empty: true});
          }
        }
      }
      // 修正current最大值，保证最后一张卡片能完整显示
      const maxCurrent = Math.max(0, displayNFTs.length - VISIBLE_COUNT);
      if (current > maxCurrent) current = maxCurrent;
      track.innerHTML = '';
      displayNFTs.forEach((nft, i) => {
        let card;
        if (nft && !nft.empty) {
          card = createNFTCard(nft, false);
        } else {
          card = createEmptyCard(false);
        }
        track.appendChild(card);
      });
      setTimeout(() => {
        const scrollTo = (CARD_WIDTH + CARD_GAP) * current;
        track.scrollTo({ left: scrollTo, behavior: 'smooth' });
      }, 0);
      document.getElementById('leftArrow').disabled = current === 0;
      document.getElementById('rightArrow').disabled = current >= maxCurrent;
      // 更新计数器
      const counter = document.getElementById('nftCounter');
      if (counter) {
        const count = nfts.length;
        counter.innerText = `${count} Box Collected`;
      }
      // 控制批量按钮显示
      const batchDiv = document.getElementById('batchActions');
      if (batchDiv) {
        if (isNFTsLoaded && nfts.length > 0) {
          batchDiv.style.display = 'flex';
        } else {
          batchDiv.style.display = 'none';
        }
      }
    }

    function createNFTCard(nft, isActive) {
      const card = document.createElement('div');
      card.className = `nft-card ${nft.revealed ? RARITY_CLASS[nft.rarity] : ''} ${isActive ? 'active' : ''}`;
      // 选中效果
      if (selectedTokenIds.has(nft.tokenId)) {
        card.classList.add('selected');
      }
      // 卡片图片区
      const imgDiv = document.createElement('div');
      imgDiv.className = 'card-img';
      if (nft.image) {
        const img = document.createElement('img');
        img.src = nft.image;
        img.alt = nft.name || 'NFT';
        img.draggable = false;
        imgDiv.appendChild(img);
      } else {
        const q = document.createElement('div');
        q.className = 'question';
        q.innerText = '?';
        imgDiv.appendChild(q);
      }
      // 点击图片区域切换选中
      imgDiv.style.cursor = 'pointer';
      imgDiv.onclick = function(e) {
        e.stopPropagation();
        if (selectedTokenIds.has(nft.tokenId)) {
          selectedTokenIds.delete(nft.tokenId);
          card.classList.remove('selected');
        } else {
          selectedTokenIds.add(nft.tokenId);
          card.classList.add('selected');
        }
        updateSelectionInfo();
      };
      card.appendChild(imgDiv);
      // 卡片内容区
      const content = document.createElement('div');
      content.className = 'card-content';

      // rarity
      const rarityWrapper = document.createElement('div');
      rarityWrapper.className = 'nft-rarity-wrapper';
      if (nft.revealed && nft.type !== 'special') {
        const rarityDiv = document.createElement('div');
        rarityDiv.className = 'nft-rarity';
        rarityDiv.innerText = RARITY_LABEL[nft.rarity] || 'COMMON';
        rarityWrapper.appendChild(rarityDiv);
        
        // 如果NFT为revealed状态且physical为true，显示Physical标签
        if (nft.physical) {
          const physicalTag = document.createElement('span');
          physicalTag.className = 'physical-tag';
          physicalTag.innerText = 'Physical';
          rarityWrapper.appendChild(physicalTag);
        }
      }
      content.appendChild(rarityWrapper);

      // name
      const nameWrapper = document.createElement('div');
      nameWrapper.className = 'nft-name-wrapper';
      const nameDiv = document.createElement('div');
      nameDiv.className = 'nft-name';
      nameDiv.innerText = nft.name || 'NFT Name';
      nameWrapper.appendChild(nameDiv);
      // 新增description字段
      if (nft.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'nft-desc';
        descDiv.innerText = nft.description;
        nameWrapper.appendChild(descDiv);
      }
      content.appendChild(nameWrapper);

      // 按钮
      const btnWrapper = document.createElement('div');
      btnWrapper.className = 'nft-btn-wrapper';
      // rewardNFT只显示TOYLIZE按钮
      if (nft.tokenId && Number(nft.tokenId) >= 20000) {
        const toylizeBtn = document.createElement('button');
        toylizeBtn.className = 'nft-btn toylize';
        toylizeBtn.innerText = 'TOYLIZE';
        toylizeBtn.onclick = () => toylizeNFT(nft.tokenId);
        btnWrapper.appendChild(toylizeBtn);
      } else if (nft.revealed) {
        if (nft.physical) {
          btnWrapper.className = 'nft-btn-wrapper physical';
          const toylizeWrapper = document.createElement('div');
          toylizeWrapper.className = 'toylize-tooltip-wrapper';
          const toylizeBtn = document.createElement('button');
          toylizeBtn.className = 'nft-btn toylize';
          toylizeBtn.innerText = 'TOYLIZE';
          toylizeBtn.onclick = () => toylizeNFT(nft.tokenId);
          const tooltip = document.createElement('div');
          tooltip.className = 'tooltip toylize-tooltip';
          tooltip.innerText = 'Burn this box to get the PHYSICAL TOY!';
          toylizeWrapper.appendChild(toylizeBtn);
          toylizeWrapper.appendChild(tooltip);
          btnWrapper.appendChild(toylizeWrapper);
        } else {
        const burnBtn = document.createElement('button');
        burnBtn.className = 'nft-btn burn';
        burnBtn.innerText = 'BURN';
        burnBtn.onclick = () => burnNFT(nft.tokenId);
        btnWrapper.appendChild(burnBtn);
        }
      } else if (nft.type === 'special') {
        const specialBurnBtn = document.createElement('button');
        specialBurnBtn.className = 'nft-btn special-burn';
        specialBurnBtn.innerText = 'SPECIAL BURN';
        specialBurnBtn.onclick = () => specialBurn(nft.tokenId);
        btnWrapper.appendChild(specialBurnBtn);
      } else {
        const revealBtn = document.createElement('button');
        revealBtn.className = 'nft-btn reveal';
        revealBtn.innerText = 'REVEAL';
        revealBtn.onclick = () => revealNFT(nft.tokenId);
        btnWrapper.appendChild(revealBtn);
      }
      content.appendChild(btnWrapper);
      
      card.appendChild(content);
      return card;
    }
    function createEmptyCard(isActive) {
      const card = document.createElement('div');
      card.className = `nft-card empty${isActive ? ' active' : ''}`;
      card.style.position = 'relative';
      // 斜线（覆盖整个卡片）
      const diagonal = document.createElement('div');
      diagonal.className = 'empty-diagonal';
      diagonal.innerHTML = `<svg class=\"empty-diagonal-line\" width=\"100%\" height=\"100%\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\"><line x1=\"10\" y1=\"10\" x2=\"90\" y2=\"90\" stroke=\"#ccc\" stroke-width=\"0.5\" stroke-linecap=\"round\"/></svg>`;
      card.appendChild(diagonal);
      // EMPTY文字
      const text = document.createElement('div');
      text.className = 'empty-text';
      text.innerText = 'EMPTY';
      card.appendChild(text);
      // 下面是原有的卡片结构
      const imgDiv = document.createElement('div');
      imgDiv.className = 'card-img empty';
      card.appendChild(imgDiv);
      const content = document.createElement('div');
      content.className = 'card-content';
      card.appendChild(content);
      return card;
    }

    // ========== 轮播交互 =============
    document.getElementById('leftArrow').onclick = function() {
      if (current > 0) {
        current--;
        renderCarousel();
      }
    };
    document.getElementById('rightArrow').onclick = function() {
      // 这里要和renderCarousel里的maxCurrent一致
      let displayNFTs = [];
      if (!isNFTsLoaded) {
        for (let i = 0; i < MIN_CARDS; i++) displayNFTs.push({empty: true});
      } else {
        displayNFTs = nfts.slice();
        for (let i = 0; i < 2; i++) displayNFTs.push({empty: true});
        if (displayNFTs.length < MIN_CARDS) {
          for (let i = displayNFTs.length; i < MIN_CARDS; i++) {
            displayNFTs.push({empty: true});
          }
        }
      }
      const maxCurrent = Math.max(0, displayNFTs.length - VISIBLE_COUNT);
      if (current < maxCurrent) {
        current++;
        renderCarousel();
      }
    };

    // ========== 合约交互 =============
    async function burnNFT(tokenId) {
      if (!contract) return;
      showModal(`Are you sure you want to burn Token ID: ${tokenId}?<br>This action is irreversible!`, {
        buttons: [
          { text: 'Cancel', onClick: null },
          { text: 'Confirm', primary: true, onClick: async () => {
            try {
              const tx = await contract.burn(tokenId);
              await tx.wait();
              showModal(`Token ID: ${tokenId} burned successfully!<br>Tx: ${tx.hash}`);
              await handleRefresh();
            } catch (err) {
              if (err && (err.code === 4001 || (err.message && err.message.toLowerCase().includes('user rejected')))) {
                showModal('Transaction was cancelled by user.');
              } else {
                showModal('Burn failed. Please try again.');
              }
            }
          }}
        ]
      });
    }
    async function revealNFT(tokenId) {
      if (!contract) return;
      showModal('Waiting for wallet confirmation...');
      try {
        const tx = await contract.reveal(tokenId);
        showModal('<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;">'
          + '<div class="modal-spinner"></div>'
          + '<div style="margin-top:8px;">Revealing...</div></div>');
        await tx.wait();
        // Reveal成功后，获取新NFT的metadata并弹窗展示
        try {
          const metadata = await fetchRevealedMetadata(tokenId, 5, 1200);
          const imageUrl = metadata.image ? (metadata.image.startsWith('ipfs://') ? metadata.image.replace('ipfs://', 'https://ipfs.io/ipfs/') : metadata.image) : '';
          const name = metadata.name || 'NFT';
          let rarity = '';
          if (metadata.attributes && Array.isArray(metadata.attributes)) {
            const rarityAttr = metadata.attributes.find(a => a.trait_type && a.trait_type.toLowerCase() === 'rarity');
            if (rarityAttr && rarityAttr.value) rarity = rarityAttr.value;
          }
          // 稀有度背景色映射
          const rarityBg = {
            legendary: '#e18701',
            epic: '#9e08c7',
            rare: '#009dd1',
            common: '#4d8da0'
          };
          const rarityKey = rarity ? rarity.toLowerCase() : 'common';
          const bgColor = rarityBg[rarityKey] || '#4d8da0';
          // 随机选择文案
          const phrases = ['Good luck!', 'Ta-da!', 'Opps?!'];
          const randomPhrase = phrases[Math.floor(Math.random() * phrases.length)];
          const cardHtml = `
            <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;margin:24px auto 0 auto;max-width:380px;min-width:220px;background:transparent;padding:0;">
              <div style=\"display:flex;align-items:center;justify-content:center;width:100%;\">
                <div style=\"width:160px;height:160px;flex-shrink:0;display:flex;align-items:center;justify-content:center;\">
                  ${imageUrl ? `<img src=\"${imageUrl}\" alt=\"${name}\" style=\"width:150px;height:150px;object-fit:cover;border-radius:24px;background:#fff;box-shadow:0 4px 16px rgba(0,0,0,0.10);\">` : '<div style=\"width:150px;height:150px;background:#eee;border-radius:24px;display:flex;align-items:center;justify-content:center;font-size:48px;\">?</div>'}
                </div>
                </div>
              <div style=\"margin-top:24px;display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;\">
                <div style=\"font-size:22px;font-weight:bold;color:#231F20;line-height:1.2;font-family:'Barlow Condensed',Arial,sans-serif;font-style:italic;\">${name}</div>
                <div style=\"margin-top:10px;padding:6px 18px;border-radius:12px;font-size:15px;font-weight:bold;text-transform:uppercase;color:#fff;background:${bgColor};font-family:'Barlow Condensed',Arial,sans-serif;letter-spacing:1px;\">${rarity ? rarity.toUpperCase() : ''}</div>
              </div>
              <div class=\"reveal-result-phrase\" style=\"margin-top:24px;\">${randomPhrase}</div>
            </div>
          `;
          showModal(`<div style="font-size:18px;font-weight:bold;margin-bottom:8px;">${cardHtml}</div>`, {
            buttons: [
              { text: 'OK', primary: true, onClick: async () => { await handleRefresh(); } }
            ]
          });
          setTimeout(() => {
            const modalCloseBtn = document.querySelector('.modal-close');
            if (modalCloseBtn) {
              const onClose = async () => {
                await handleRefresh();
                modalCloseBtn.removeEventListener('click', onClose);
              };
              modalCloseBtn.addEventListener('click', onClose);
            }
          }, 100);
        } catch (e) {
          showModal('Reveal successful! (But failed to load NFT metadata)', {
            buttons: [
              { text: 'OK', primary: true, onClick: async () => { await handleRefresh(); } }
            ]
          });
        }
      } catch (err) {
        if (err && (err.code === 4001 || (err.message && err.message.toLowerCase().includes('user rejected')))) {
          showModal('Transaction was cancelled by user.');
        } else {
          showModal('Reveal failed. Please try again.');
        }
      }
    }

    async function specialBurn(tokenId) {
      if (!contract) return;
      showModal('Waiting for wallet confirmation...');
      try {
        const tx = await contract.specialBurn(tokenId);
        showModal('<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;">'
          + '<div class="modal-spinner"></div>'
          + '<div style="margin-top:8px;">Special Burning...</div></div>');
        await tx.wait();
        showModal('Special Burn successful!');
        await handleRefresh();
      } catch (err) {
        if (err && (err.code === 4001 || (err.message && err.message.toLowerCase().includes('user rejected')))) {
          showModal('Transaction was cancelled by user.');
        } else {
          showModal('Special Burn failed. Please try again.');
        }
      }
    }

    async function toylizeNFT(tokenId) {
      if (!contract) return;
      showModal(`Toylize function is not yet implemented.<br>This feature will be available soon!`);
    }

    function setRefreshLoadedUI() {
      const status = document.getElementById('refreshStatusText');
      const refreshBtn = document.getElementById('refreshBtn');
      const refreshText = document.getElementById('refreshText');
      if (status) status.innerText = 'Collection loaded.';
      if (refreshBtn) refreshBtn.style.display = 'none';
      if (refreshText) refreshText.style.display = 'inline';
      refreshText.onclick = async function() {
        await handleRefresh();
      };
    }
    async function handleRefresh() {
      const btn = document.getElementById('refreshBtn');
      const status = document.getElementById('refreshStatusText');
      const refreshText = document.getElementById('refreshText');
      if (btn) btn.disabled = true;
      try {
        showModal('<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;">'
          + '<div class="modal-spinner"></div>'
          + '<div style="margin-top:8px;">Loading your collection...</div></div>');
        await loadNFTs();
        renderCarousel();
        if (nfts && nfts.length > 0 && nfts.some(nft => !nft.empty)) {
          hideModal();
          setRefreshLoadedUI();
          await updateBatchBurnResetRuler();
        } else {
          hideModal();
          showModal('No NFTs found in your wallet', {
            buttons: [{ text: 'OK', primary: true }]
          });
          if (status) status.innerText = 'No NFTs found in your collection.';
          if (btn) btn.style.display = 'inline-block';
          if (refreshText) refreshText.style.display = 'none';
        }
      } catch (e) {
        hideModal();
        showModal('Failed to load collection. Please try again.', {
          buttons: [{ text: 'OK', primary: true }]
        });
        if (status) status.innerText = 'Failed to load your collection';
      }
      if (btn) btn.disabled = false;
      await updateMintStatus();
      await updateBatchBurnResetRuler();
    }
    document.getElementById('refreshBtn').onclick = handleRefresh;
    
    // 挂载到window对象，供外部调用
    window.handleRefresh = handleRefresh;

    // ===================== 弹窗函数 =====================
    function showModal(message, options) {
      const modalContainer = document.getElementById('modalContainer');
      let buttonsHtml = '';
      if (options && Array.isArray(options.buttons)) {
        buttonsHtml = '<div class="modal-btns">' +
          options.buttons.map((btn, i) => `<button class="modal-btn${btn.primary ? ' primary' : ''}" onclick="window._modalBtnClick(${i})">${btn.text}</button>`).join('') +
          '</div>';
        window._modalBtnClick = function(idx) {
          hideModal();
          if (options.buttons[idx].onClick) options.buttons[idx].onClick();
        };
      }
      modalContainer.innerHTML = `
        <div class="modal-overlay">
          <div class="modal-box">
            <button class="modal-close" onclick="hideModal()"><span class="modal-close-x">&#10005;</span></button>
            <div class="modal-content">${message}</div>
            ${buttonsHtml}
          </div>
        </div>
      `;
      modalContainer.style.display = 'block';
    }
    function hideModal() {
      document.getElementById('modalContainer').style.display = 'none';
      window._modalBtnClick = null;
    }
    window.hideModal = hideModal;

    // 页面初次加载后，如果collection已加载，自动切换为loaded状态
    (function checkLoadedOnStart() {
      if (typeof nfts !== 'undefined' && nfts.length > 0 && nfts.some(nft => !nft.empty)) {
        setRefreshLoadedUI();
      }
    })();

    // ========== 拖拽滑动功能 =============
    (function enableCarouselDrag() {
      const track = document.getElementById('carouselTrack');
      let isDown = false;
      let startX = 0;
      let scrollLeft = 0;
      let dragMoved = false;
      let animationFrame;

      function getMaxScroll() {
        return Math.max(0, track.scrollWidth - track.clientWidth);
      }

      track.addEventListener('mousedown', (e) => {
        isDown = true;
        dragMoved = false;
        startX = e.pageX - track.offsetLeft;
        scrollLeft = track.scrollLeft;
        track.style.cursor = 'grabbing';
        track.style.scrollBehavior = 'auto';
        cancelAnimationFrame(animationFrame);
      });
      track.addEventListener('mouseleave', () => {
        if (isDown) snapToCard();
        isDown = false;
        track.style.cursor = '';
      });
      track.addEventListener('mouseup', () => {
        if (isDown) snapToCard();
        isDown = false;
        track.style.cursor = '';
      });
      track.addEventListener('mousemove', (e) => {
        if (!isDown) return;
        e.preventDefault();
        dragMoved = true;
        const x = e.pageX - track.offsetLeft;
        const walk = x - startX;
        track.scrollLeft = scrollLeft - walk;
      });
      // 触屏支持
      track.addEventListener('touchstart', (e) => {
        isDown = true;
        dragMoved = false;
        startX = e.touches[0].pageX - track.offsetLeft;
        scrollLeft = track.scrollLeft;
        track.style.scrollBehavior = 'auto';
        cancelAnimationFrame(animationFrame);
      });
      track.addEventListener('touchend', () => {
        if (isDown) snapToCard();
        isDown = false;
      });
      track.addEventListener('touchmove', (e) => {
        if (!isDown) return;
        dragMoved = true;
        const x = e.touches[0].pageX - track.offsetLeft;
        const walk = x - startX;
        track.scrollLeft = scrollLeft - walk;
      });

      function snapToCard() {
        // 计算当前scrollLeft对应的卡片index
        const rawIndex = track.scrollLeft / (CARD_WIDTH + CARD_GAP);
        let snapIndex = Math.round(rawIndex);
        // 限制范围
        const maxSnap = Math.max(0, track.children.length - VISIBLE_COUNT);
        if (snapIndex < 0) snapIndex = 0;
        if (snapIndex > maxSnap) snapIndex = maxSnap;
        // 缓动动画到目标位置
        animateScrollTo((CARD_WIDTH + CARD_GAP) * snapIndex);
        // 同步current并渲染箭头状态
        current = snapIndex;
        setTimeout(() => renderCarousel(), 300);
      }
      function animateScrollTo(target) {
        const duration = 300;
        const start = track.scrollLeft;
        const change = target - start;
        const startTime = performance.now();
        function animate(time) {
          const elapsed = time - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const ease = 0.5 - Math.cos(progress * Math.PI) / 2; // easeInOut
          track.scrollLeft = start + change * ease;
          if (progress < 1) {
            animationFrame = requestAnimationFrame(animate);
          } else {
            track.scrollLeft = target;
          }
        }
        animationFrame = requestAnimationFrame(animate);
      }
    })();

    document.getElementById('batchRevealBtn').onclick = async function() {
      if (!contract) return;
      // 收集所有被勾选的tokenId
      const tokenIds = Array.from(selectedTokenIds);
      if (tokenIds.length === 0) {
        showModal('Please select at least one NFT to batch reveal.');
        return;
      }
      if (tokenIds.length > 10) {
        showModal('You can only batch reveal up to 10 NFTs at once.');
        return;
      }
      const btn = document.getElementById('batchRevealBtn');
      btn.disabled = true;
      showModal('Waiting for wallet confirmation...');
      try {
        const tx = await contract.revealBatch(tokenIds);
        showModal('<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;">'
          + '<div class="modal-spinner"></div>'
          + '<div style="margin-top:8px;">Batch Revealing...</div></div>');
        await tx.wait();
        // Reveal结果展示
        let cardsHtml = '';
        for (let i = 0; i < tokenIds.length; i++) {
          try {
            // 新增：批量reveal也判断tokenURI文件名
            const metadata = await fetchRevealedMetadata(tokenIds[i], 5, 1200);
            const imageUrl = metadata.image ? (metadata.image.startsWith('ipfs://') ? metadata.image.replace('ipfs://', 'https://ipfs.io/ipfs/') : metadata.image) : '';
            const name = metadata.name || 'NFT';
            let rarity = '';
            if (metadata.attributes && Array.isArray(metadata.attributes)) {
              const rarityAttr = metadata.attributes.find(a => a.trait_type && a.trait_type.toLowerCase() === 'rarity');
              if (rarityAttr && rarityAttr.value) rarity = rarityAttr.value;
            }
            const rarityBg = {
              legendary: '#e18701',
              epic: '#9e08c7',
              rare: '#009dd1',
              common: '#4d8da0'
            };
            const rarityKey = rarity ? rarity.toLowerCase() : 'common';
            const bgColor = rarityBg[rarityKey] || '#4d8da0';
            cardsHtml += `
              <div style=\"display:flex;flex-direction:column;align-items:center;justify-content:center;margin:18px 12px 0 12px;max-width:180px;min-width:120px;background:transparent;padding:0;\">
                <div style=\"width:90px;height:90px;flex-shrink:0;display:flex;align-items:center;justify-content:center;\">
                  ${imageUrl ? `<img src=\"${imageUrl}\" alt=\"${name}\" draggable=\"false\" style=\"width:80px;height:80px;object-fit:cover;border-radius:16px;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,0.10);user-select:none;-webkit-user-drag:none;\">` : '<div style=\"width:80px;height:80px;background:#eee;border-radius:16px;display:flex;align-items:center;justify-content:center;font-size:28px;\">?</div>'}
                </div>
                <div style=\"margin-top:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;\">
                  <div style=\"font-size:15px;font-weight:bold;color:#231F20;line-height:1.2;font-family:'Barlow Condensed',Arial,sans-serif;font-style:italic;\">${name}</div>
                  <div style=\"margin-top:6px;padding:4px 12px;border-radius:8px;font-size:12px;font-weight:bold;text-transform:uppercase;color:#fff;background:${bgColor};font-family:'Barlow Condensed',Arial,sans-serif;letter-spacing:1px;\">${rarity ? rarity.toUpperCase() : ''}</div>
                </div>
              </div>
            `;
          } catch (e) {
            // 保持卡片样式一致，图片用深灰色底，名称显示Fail to load，稀有度空
            cardsHtml += `
              <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;margin:18px 12px 0 12px;max-width:180px;min-width:120px;background:transparent;padding:0;">
                <div style=\"width:90px;height:90px;flex-shrink:0;display:flex;align-items:center;justify-content:center;background:#444;border-radius:16px;\">
                  <span style=\"color:#fff;font-size:38px;font-weight:bold;user-select:none;\">?</span>
                </div>
                <div style=\"margin-top:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;\">
                  <div style=\"font-size:15px;font-weight:bold;color:#231F20;line-height:1.2;font-family:'Barlow Condensed',Arial,sans-serif;font-style:italic;\">Fail to load</div>
                  <div style=\"margin-top:6px;padding:4px 12px;border-radius:8px;font-size:12px;font-weight:bold;text-transform:uppercase;color:#fff;background:transparent;font-family:'Barlow Condensed',Arial,sans-serif;letter-spacing:1px;\"></div>
                </div>
              </div>
            `;
          }
        }
        // batch reveal 结果弹窗内容结构优化
        const batchRevealModalHtml = `
          <div style="width:100%;max-width:30vw;display:flex;flex-direction:column;align-items:center;">
            <div style="font-size:20px;font-weight:bold;margin-bottom:18px;text-align:center;width:100%;">Batch Reveal successful!</div>
            <div id="batchRevealResultScroll" style="display:flex;flex-wrap:nowrap;overflow-x:auto;overflow-y:hidden;justify-content:flex-start;align-items:flex-start;gap:0 8px;width:100%;max-width:28vw;padding-bottom:8px;scrollbar-width:none;-ms-overflow-style:none;">
              ${cardsHtml}
            </div>
            <style>
              #batchRevealResultScroll::-webkit-scrollbar { display: none; }
            </style>
          </div>
        `;
        showModal(batchRevealModalHtml, {
          buttons: [
            { text: 'OK', primary: true, onClick: async () => { await handleRefresh(); } }
          ]
        });
        // 恢复横向拖拽滚动逻辑
        setTimeout(() => {
          const scrollDiv = document.getElementById('batchRevealResultScroll');
          if (scrollDiv) {
            let isDown = false;
            let startX, scrollLeft;
            scrollDiv.addEventListener('mousedown', (e) => {
              isDown = true;
              scrollDiv.classList.add('dragging');
              startX = e.pageX - scrollDiv.offsetLeft;
              scrollLeft = scrollDiv.scrollLeft;
              e.preventDefault();
            });
            scrollDiv.addEventListener('mouseleave', () => { isDown = false; scrollDiv.classList.remove('dragging'); });
            scrollDiv.addEventListener('mouseup', () => { isDown = false; scrollDiv.classList.remove('dragging'); });
            scrollDiv.addEventListener('mousemove', (e) => {
              if (!isDown) return;
              const x = e.pageX - scrollDiv.offsetLeft;
              const walk = (x - startX) * 1.2;
              scrollDiv.scrollLeft = scrollLeft - walk;
            });
            // 支持触摸拖动
            let touchStartX = 0, touchScrollLeft = 0;
            scrollDiv.addEventListener('touchstart', (e) => {
              isDown = true;
              touchStartX = e.touches[0].pageX;
              touchScrollLeft = scrollDiv.scrollLeft;
            });
            scrollDiv.addEventListener('touchend', () => { isDown = false; });
            scrollDiv.addEventListener('touchmove', (e) => {
              if (!isDown) return;
              const x = e.touches[0].pageX;
              const walk = (x - touchStartX) * 1.2;
              scrollDiv.scrollLeft = touchScrollLeft - walk;
            });
          }
          // 关闭按钮监听
          const modalCloseBtn = document.querySelector('.modal-close');
          if (modalCloseBtn) {
            const onClose = async () => {
              await handleRefresh();
              modalCloseBtn.removeEventListener('click', onClose);
            };
            modalCloseBtn.addEventListener('click', onClose);
          }
        }, 100);
        selectedTokenIds.clear();
        updateSelectionInfo();
        // await handleRefresh(); // 移除这里的自动刷新
      } catch (err) {
        let msg = 'Batch Reveal failed. Please try again.';
        if (err && err.message) {
          const emsg = err.message.toLowerCase();
          if (emsg.includes('already revealed')) {
            msg = 'Selected cards already revealed.';
          } else if (emsg.includes('not owner')) {
            msg = 'You are not the owner of some selected cards.';
          } else if (emsg.includes('revert')) {
            // 尝试提取revert原因
            const match = err.message.match(/revert(?:ed)?[:\s]*([^\n]+)/i);
            if (match && match[1]) msg = match[1].trim();
        } else {
            msg = err.message;
        }
        }
        showModal(msg);
      }
      btn.disabled = false;
      setTimeout(() => {
        const modalCloseBtn = document.querySelector('.modal-close');
        if (modalCloseBtn) {
          const onClose = async () => {
            await handleRefresh();
            modalCloseBtn.removeEventListener('click', onClose);
          };
          modalCloseBtn.addEventListener('click', onClose);
        }
      }, 100);
    };

    document.getElementById('batchBurnBtn').onclick = async function() {
      if (!contract) return;
      // 收集所有被勾选的tokenId
      const tokenIds = Array.from(selectedTokenIds);
      if (tokenIds.length === 0) {
        showModal('Please select at least one NFT to batch burn.');
        return;
      }
      if (tokenIds.length < 6) {
        showModal('You need to burn at least 6 boxes to get a brand new box.');
        return;
      }
      const btn = document.getElementById('batchBurnBtn');
      btn.disabled = true;
      showModal('Waiting for wallet confirmation...');
      try {
        const tx = await contract.batchBurnAndReset(tokenIds);
        showModal('<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;">'
          + '<div class="modal-spinner"></div>'
          + '<div style="margin-top:8px;">Batch Burning...</div></div>');
        await tx.wait();
        showModal('Batch Burn successful!');
        selectedTokenIds.clear();
        updateSelectionInfo();
        await handleRefresh();
        await updateBatchBurnResetRuler();
      } catch (err) {
        if (err && (err.code === 4001 || (err.message && err.message.toLowerCase().includes('user rejected')))) {
          showModal('Transaction was cancelled by user.');
        } else {
          showModal('Batch Burn failed. Please try again.');
        }
        // 不再刷新NFT列表
      }
      btn.disabled = false;
    };

    // ========== Mint Row JS逻辑 =============
    (function(){
      // 避免变量冲突，全部加前缀profileMint_
      const mintBtn = document.getElementById('mintBtn');
      const mintStatus = document.getElementById('mintStatus');
      const mintProgress = document.getElementById('mintProgress');
      const mintSlider = document.getElementById('mintSlider');
      const sliderValueBox = document.getElementById('sliderValueBox');
      let mintCount = 10;
      const MIN_MINT = 1;
      const MAX_MINT = 10;
      // 进度条与数字联动
      function updateSliderBox() {
        const val = parseInt(mintSlider.value);
        sliderValueBox.innerText = val;
        // 滑块宽度=260px, thumb宽28px，left范围0~232
        const left = ((val - MIN_MINT) / (MAX_MINT - MIN_MINT)) * (260 - 28);
        sliderValueBox.style.left = left + 'px';
      }
      mintSlider.addEventListener('input', function() {
        mintCount = parseInt(this.value);
        updateSliderBox();
      });
      updateSliderBox();
      // 合约进度
      async function updateMintStatus() {
        if (!window.contract) {
          document.getElementById('mintProgress').innerText = '--/888';
          mintPriceEth.innerHTML = '--<small>ETH</small>';
          document.getElementById('burnedCountDisplay').innerText = '';
          return;
        }
        try {
          const total = await window.contract.totalSupply();
          const max = await window.contract.MAX_SUPPLY();
          document.getElementById('mintProgress').innerText = `${total}/${max}`;
          // 动态获取mint价格
          const price = await window.contract.PRICE();
          const ethPrice = ethers.utils.formatEther(price);
          mintPriceEth.innerHTML = `${ethPrice}<small>ETH</small>`;
          // 获取burnedCount
          let burned = 0;
          try {
            burned = await window.contract.burnedCount();
          } catch (e) {}
          const burnedSpan = document.getElementById('burnedCountDisplay');
          if (burned && burned.toString() !== '0') {
            burnedSpan.innerHTML = `（${burned} BURNED）`;
          } else {
            burnedSpan.innerHTML = '';
          }
        } catch (e) {
          document.getElementById('mintProgress').innerText = '--/888';
          mintPriceEth.innerHTML = '--<small>ETH</small>';
          document.getElementById('burnedCountDisplay').innerText = '';
        }
      }
      // mint按钮逻辑
      mintBtn.onclick = async function() {
        if (!window.contract || !window.userAccount) {
          showModal('Please connect your wallet first.', { buttons: [ { text: 'OK', primary: true } ] });
          return;
        }
        const count = mintCount;
        try {
          const saleIsActive = await window.contract.saleIsActive();
          if (!saleIsActive) {
            showModal('Mint is not started yet.', { buttons: [ { text: 'OK', primary: true } ] });
            return;
          }
          if (count < 1 || count > 10) {
            showModal('Mint count must be between 1 and 10.', { buttons: [ { text: 'OK', primary: true } ] });
            return;
          }
          const price = await window.contract.PRICE();
          const totalPrice = price.mul(count);
          showModal('Waiting for wallet confirmation...');
          const tx = await window.contract.mint(count, { value: totalPrice });
          showModal('<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;"><div class="modal-spinner"></div><div style="margin-top:8px;">Minting...</div></div>');
          await tx.wait();
          showModal('Mint successful!');
          await updateMintStatus();
          if (typeof window.handleRefresh === 'function') await window.handleRefresh();
        } catch (err) {
          if (err && (err.code === 4001 || (err.message && err.message.toLowerCase().includes('user rejected')))) {
            showModal('Transaction was cancelled by user.', { buttons: [ { text: 'OK', primary: true } ] });
          } else {
            showModal('Mint failed. Please try again.', { buttons: [ { text: 'OK', primary: true } ] });
          }
        }
      };
      // 页面加载后自动刷新mint进度
      updateMintStatus();
      // 挂到window，供外部调用
      window.updateMintStatus = updateMintStatus;
    })();

    // ========== 选择信息更新 =============
    function updateSelectionInfo() {
      const selectionInfo = document.getElementById('selectionInfo');
      const selectionCount = document.getElementById('selectionCount');
      const count = selectedTokenIds.size;
      
      if (count > 0) {
        selectionInfo.style.display = 'flex';
        selectionCount.innerText = `${count} selected`;
      } else {
        selectionInfo.style.display = 'none';
      }
    }
    
    // unselect all按钮事件
    document.getElementById('unselectAllBtn').onclick = function() {
      selectedTokenIds.clear();
      // 移除所有卡片的选中样式
      document.querySelectorAll('.nft-card.selected').forEach(card => {
        card.classList.remove('selected');
      });
      updateSelectionInfo();
    };

    // ========== 鼠标滚轮滚动功能 =============
    (function enableCarouselWheelScroll() {
      const track = document.getElementById('carouselTrack');
      track.addEventListener('wheel', function(e) {
        // 只在有横向滚动条时生效
        if (track.scrollWidth > track.clientWidth) {
          e.preventDefault();
          // e.deltaY为正向下滚，负向上滚
          track.scrollLeft += e.deltaY;
        }
      }, { passive: false });
    })();

    // ========== 触控板滚动功能 =============
    (function enableCarouselTouchPadScroll() {
      const track = document.getElementById('carouselTrack');
      track.addEventListener('wheel', function(e) {
        if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
          // 横向滚动为主，通常为触控板手势
          e.preventDefault();
          track.scrollLeft += e.deltaX;
        }
      }, { passive: false });
    })();

    // ruler计数器
    async function updateBatchBurnResetRuler() {
      if (!contract || !userAccount) {
        document.getElementById('batchBurnResetRuler').innerHTML = '';
        return;
      }
      try {
        const count = await contract.userBatchBurnResetCount(userAccount);
        const ruler = count % 3;
        // 新逻辑：0=全灰，1/2=下两条粉色，上面灰
        let bar0 = '#bbb', bar1 = '#bbb', bar2 = '#bbb';
        if (ruler === 1 || ruler === 2) {
          bar1 = '#FF00F9';
          bar2 = '#FF00F9';
        }
        // 构建三条横条
        let bars = '';
        bars += `<div class='ruler-bar ruler-bar-0' style='background:${bar0};'></div>`;
        bars += `<div class='ruler-bar ruler-bar-1' style='background:${bar1};'></div>`;
        bars += `<div class='ruler-bar ruler-bar-2' style='background:${bar2};'></div>`;
        document.getElementById('batchBurnResetRuler').innerHTML = `
          <div class='ruler-bars'>${bars}</div>
          <div class='ruler-labels'>
            <div class='ruler-label-special'>SPECIAL</div>
            <div class='ruler-label-reward'>REWARD</div>
          </div>
        `;
      } catch (e) {
        document.getElementById('batchBurnResetRuler').innerHTML = '';
      }
    }

    function isRevealedTokenURI(tokenURI) {
      const filename = tokenURI.split('/').pop();
      return /^\d+\.json$/.test(filename);
    }
    async function fetchRevealedMetadata(tokenId, maxTries = 5, interval = 1200) {
      for (let i = 0; i < maxTries; i++) {
        const tokenURI = await contract.tokenURI(tokenId);
        if (isRevealedTokenURI(tokenURI)) {
          const url = tokenURI.startsWith('ipfs://') ? tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/') : tokenURI;
          const response = await fetch(url + '?t=' + Date.now(), { cache: 'reload' });
          return await response.json();
        }
        await new Promise(res => setTimeout(res, interval));
      }
      throw new Error('Metadata not updated in time');
    }
  </script>
  <script>
    // 选中卡片样式
    (function(){
      const style = document.createElement('style');
      style.innerHTML = `
        .nft-card.selected {
          box-shadow: 0 0 0 4px #FF00F9, 0 8px 32px rgba(0,0,0,0.10);
          transform: translateY(-5px);
          z-index: 1;
          transition: box-shadow 0.18s, transform 0.0s;
        }
      `;
      document.head.appendChild(style);
    })();
  </script>
  
</body>
</html> 