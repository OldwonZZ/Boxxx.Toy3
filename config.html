<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>Contract Configuration</title>
  <!-- å¼•å…¥ ethers.js åº“ï¼ˆç”¨äºä¸ä»¥å¤ªåŠåˆçº¦äº¤äº’ï¼‰ -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js" type="application/javascript"></script>
  <style>
    body { 
      font-family: 'Arial', sans-serif; 
      padding: 20px; 
      background-color: #f5f5f5;
      color: #333;
      margin: 0;
    }
    
    h1 {
      color: #000;
      text-align: center;
      margin-bottom: 30px;
      font-weight: 300;
    }
    
    button { 
      font-size: 14px; 
      padding: 8px 16px; 
      margin: 5px 5px 5px 0;
      background-color: #000;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
    }
    
    button:hover {
      background-color: #333;
      transform: translateY(-1px);
    }
    
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    
    input[type="text"], input[type="number"] {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      background-color: #fff;
      color: #333;
      transition: border-color 0.3s ease;
    }
    
    input[type="text"]:focus, input[type="number"]:focus {
      outline: none;
      border-color: #000;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
    }
    
    label {
      font-weight: 600;
      color: #000;
      margin-bottom: 5px;
      display: inline-block;
    }
    
    #mintStatus, #adminStatus, #ownerStatus, #specialURIStatus, #specialMintStatus, #batchBurnThresholdStatus, #withdrawStatus { 
      margin-top: 10px; 
      color: #666;
      font-size: 14px;
    }
    
    .mint-section {
      margin-top: 30px;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      width: 100%;
      box-sizing: border-box;
      margin-left: auto;
      margin-right: auto;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .mint-section input { 
      width: 80px; 
      padding: 8px; 
      font-size: 14px; 
      margin-right: 10px;
    }
    
    .mint-section label { 
      font-weight: 600; 
      margin-right: 10px;
    }
    
    .admin-section {
      margin-top: 30px;
      padding: 20px;
      border: 1px solid #000;
      border-radius: 8px;
      width: 100%; 
      box-sizing: border-box;
      background: #fff;
      margin-left: auto;
      margin-right: auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .admin-section h3 {
      color: #000;
      margin-top: 0;
      margin-bottom: 20px;
      font-weight: 600;
    }
    
    .admin-section hr {
      border: none;
      border-top: 1px solid #eee;
      margin: 20px 0;
    }
    
    /* ====== é’±åŒ…è¿æ¥æ ·å¼ ====== */
    .wallet-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 5px;
        padding: 15px 20px;
        background-color: #fff;
        border-bottom: 1px solid #eee;
        margin-bottom: 30px;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    .logo-container {
        display: flex;
        align-items: center;
    }
    .logo {
        height: 60px;
        width: 60px;
        object-fit: contain;
    }
    .wallet-controls {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        gap: 10px;
    }
    #walletInfo {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        justify-content: flex-end;
        align-content: center;
        font-family: 'Arial', sans-serif;
        font-size: 14px;
        font-weight: 500;
        padding: 8px 12px;
        min-width: 180px;
        height: 36px;
        display: flex;
        align-items: center;
        text-align: right;
        transition: all 0.3s ease;
        border-radius: 4px;
    }
    #connectMetaMaskButton {
        width: 160px;
        height: 36px;
        background-color: #000;
        border: none;
        font-family: 'Arial', sans-serif;
        font-size: 14px;
        font-weight: 500;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        border-radius: 4px;
    }
    #connectMetaMaskButton:hover {
        background-color: #333;
        transform: translateY(-1px);
    }
    #connectMetaMaskButton:active {
        background-color: #000;
        transform: translateY(0);
    }
    #connectMetaMaskButton.disconnect {
        background-color: #000;
        cursor: pointer;
    }
    #connectMetaMaskButton.disconnect:hover {
        background-color: #333; 
    }
    #walletInfo.connected {
        color: #000;
        background-color: #f0f0f0;
    }
    #walletInfo.wrong-chain {
        color: #d32f2f;
        background-color: #ffebee;
    }
    #walletInfo.disconnected {
        color: #666;
        background-color: #f5f5f5;
    }
    
    /* ç‰¹æ®ŠæŒ‰é’®æ ·å¼ */
    #refreshBalanceBtn {
        background-color: #000;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        margin-left: 10px;
    }
    
    #refreshBalanceBtn:hover {
        background-color: #333;
    }
    
    #withdrawBtn {
        background-color: #000;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
    }
    
    #withdrawBtn:hover {
        background-color: #333;
    }
    
    #batchRevealBtn {
        background-color: #000;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }
    
    #batchRevealBtn:hover {
        background-color: #333;
    }
    
    #batchBurnBtn {
        background-color: #000;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }
    
    #batchBurnBtn:hover {
        background-color: #333;
    }
    
    /* NFT å¡ç‰‡æ ·å¼ */
    .nft-card {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        background-color: #fff;
        transition: all 0.3s ease;
    }
    
    .nft-card:hover {
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        transform: translateY(-2px);
    }
    
    .nft-card.selected {
        border-color: #000;
        background-color: #f8f8f8;
    }
    
    .nft-card input[type="checkbox"] {
        margin-right: 10px;
    }
    
    .nft-card button {
        margin: 5px 5px 5px 0;
        font-size: 12px;
        padding: 6px 12px;
    }
  </style>
</head>
<body>
  <!-- é’±åŒ…è¿æ¥åŒºåŸŸ -->
  <div class="wallet-container">
    <div class="logo-container">
      <img src="toy3logo.png" alt="Logo" class="logo">
    </div>
    <div class="wallet-controls">
      <div id="walletInfo"></div>
      <button id="connectMetaMaskButton">Connect MetaMask</button>
    </div>
  </div>

  <h1>Contract Configuration</h1>
    
  <!-- ç®¡ç†å‘˜æ§åˆ¶mintå¼€å…³åŒºï¼ˆä»…åˆçº¦Ownerå¯è§ï¼‰ -->
  <div class="admin-section" id="adminSection" style="display:none;">
    <label>Mint Toggle:</label>
    <button id="toggleSaleBtn">Loading...</button>
    <div id="adminStatus"></div>
    <hr>
    <div>
      <label for="baseURIInput">Base URI (for unrevealed metadata):</label><br>
      <input type="text" id="baseURIInput" placeholder="ipfs://cid_for_unrevealed/">
      <button id="setBaseURIBtn">Set Base URI</button>
    </div>
    <div style="margin-top: 15px;">
      <label for="ipfsBaseURIInput">IPFS Base URI (for revealed metadata):</label><br>
      <input type="text" id="ipfsBaseURIInput" placeholder="ipfs://cid_for_revealed/">
      <button id="setIpfsBaseURIBtn">Set IPFS Base URI</button>
    </div>
    <div style="margin-top: 15px;">
      <label for="specialURIInput">Special URI (for special NFTs):</label><br>
      <input type="text" id="specialURIInput" placeholder="ipfs://cid_for_special/special.json">
      <button id="setSpecialURIBtn">Set Special URI</button>
      <span id="specialURIStatus"></span>
    </div>
    <div id="ownerStatus" style="margin-top: 10px;"></div>
    <hr>
    <div>
      <label for="batchBurnThresholdInput">Batch Burn æœ€ä½æ•°é‡ï¼š</label>
      <input type="number" id="batchBurnThresholdInput" min="1" value="10" style="width:80px;">
      <button id="setBatchBurnThresholdBtn">è®¾ç½®</button>
      <span id="batchBurnThresholdStatus"></span>
    </div>
    <hr>
    <div>
      <label for="specialMintCount">Special Mint æ•°é‡ï¼š</label>
      <input type="number" id="specialMintCount" min="1" value="1" style="width:80px;">
      <label for="specialMintTo">æ¥æ”¶åœ°å€ï¼š</label>
      <input type="text" id="specialMintTo" style="width:260px;" placeholder="é»˜è®¤è‡ªå·±åœ°å€">
      <button id="specialMintBtn">Special Mint</button>
      <span id="specialMintStatus"></span>
    </div>
    <hr>
    <div>
      <h3>ğŸ’° åˆçº¦èµ„é‡‘ç®¡ç†</h3>
      <div style="margin-bottom: 15px;">
        <strong>åˆçº¦ä½™é¢ï¼š</strong><span id="contractBalance">åŠ è½½ä¸­...</span>
        <button id="refreshBalanceBtn">åˆ·æ–°</button>
      </div>
      <button id="withdrawBtn">æå–æ‰€æœ‰èµ„é‡‘</button>
      <div id="withdrawStatus" style="margin-top: 10px;"></div>
    </div>
  </div>

  <!-- Mint NFT åŠŸèƒ½åŒº -->
  <div class="mint-section">
    <label for="mintCount">Mint Amount (max 10 per time, unlimited per wallet):</label><br>
    <input type="number" id="mintCount" min="1" max="10" value="1">
    <button id="mintBtn">Mint</button>
    <div id="mintStatus"></div>
  </div>

  <!-- æˆ‘çš„NFTæŸ¥çœ‹å’ŒRevealåŠŸèƒ½åŒº -->
  <div class="mint-section" id="myNFTSection" style="margin-top:40px;">
    <h2>My NFTs</h2>
    <button id="refreshNFTBtn" style="margin-bottom:10px;">Refresh</button>
    <button id="batchRevealBtn" style="margin-bottom:10px; margin-left:10px;">Batch Reveal</button>
    <button id="batchBurnBtn" style="margin-bottom:10px; margin-left:10px;">Batch Burn</button>
    <div id="nftList">Loading...</div>
  </div>

  <script>
    // ===================== å˜é‡å’ŒDOMå…ƒç´ è·å– =====================
    const mintBtn = document.getElementById('mintBtn');       // Mint æŒ‰é’®
    const mintCountInput = document.getElementById('mintCount'); // Mint æ•°é‡è¾“å…¥æ¡†
    const mintStatus = document.getElementById('mintStatus'); // çŠ¶æ€æç¤º
    const adminSection = document.getElementById('adminSection'); // ç®¡ç†å‘˜åŒº
    const toggleSaleBtn = document.getElementById('toggleSaleBtn'); // å¼€å…³æŒ‰é’®
    const adminStatus = document.getElementById('adminStatus'); // ç®¡ç†å‘˜çŠ¶æ€
    const nftListDiv = document.getElementById('nftList');
    const refreshNFTBtn = document.getElementById('refreshNFTBtn');
    const batchBurnBtn = document.getElementById('batchBurnBtn');
    const batchBurnThresholdInput = document.getElementById('batchBurnThresholdInput');
    const setBatchBurnThresholdBtn = document.getElementById('setBatchBurnThresholdBtn');
    const batchBurnThresholdStatus = document.getElementById('batchBurnThresholdStatus');
    const batchRevealBtn = document.getElementById('batchRevealBtn');
    const specialMintCount = document.getElementById('specialMintCount');
    const specialMintTo = document.getElementById('specialMintTo');
    const specialMintBtn = document.getElementById('specialMintBtn');
    const specialMintStatus = document.getElementById('specialMintStatus');
    const baseURIInput = document.getElementById('baseURIInput');
    const setBaseURIBtn = document.getElementById('setBaseURIBtn');
    const ipfsBaseURIInput = document.getElementById('ipfsBaseURIInput');
    const setIpfsBaseURIBtn = document.getElementById('setIpfsBaseURIBtn');
    const ownerStatus = document.getElementById('ownerStatus');
    const specialURIInput = document.getElementById('specialURIInput');
    const setSpecialURIBtn = document.getElementById('setSpecialURIBtn');
    const specialURIStatus = document.getElementById('specialURIStatus');

    let provider = null;    // ethers.js provider
    let signer = null;      // ethers.js signer
    let contract = null;    // åˆçº¦å®ä¾‹
    let isOwner = false;    // æ˜¯å¦ä¸ºåˆçº¦Owner
    let saleIsActive = false; // mintæ˜¯å¦å¼€å¯
    let defaultBaseURIOnChain = null; // æ–°å¢ï¼šé“¾ä¸Šæœªæ­ç¤ºmetadataé“¾æ¥
    let selectedNFTs = new Set();

    // ===================== åˆçº¦åœ°å€å’ŒABI =====================
    const contractAddress = "0x0a1d2dee15cc7548a433203992417037afe91c99"; // éƒ¨ç½²åœ¨Sepoliaçš„åˆçº¦åœ°å€
    const contractABI = [
      // Functions for minting and sale toggle
      "function mint(uint256 count) public payable",
      "function saleIsActive() public view returns (bool)",
      "function setSaleIsActive(bool saleIsActive_) external",
      "function owner() public view returns (address)",
      "function PRICE() public view returns (uint256)",
      "function MAX_SUPPLY() public view returns (uint256)",
      "function totalSupply() public view returns (uint256)",

      // Functions for NFT viewing/revealing
      "function balanceOf(address owner) public view returns (uint256)",
      "function tokenURI(uint256 tokenId) public view returns (string)",
      "function ownerOf(uint256 tokenId) public view returns (address)",
      "function reveal(uint256 tokenId) public",
      "function burn(uint256 tokenId) public",
      "function burnBatch(uint256[] tokenIds) external",
      "function defaultBaseURI() public view returns (string)",

      // Event for finding tokens
      "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)",

      // New functions for owner
        "function setBaseURI(string calldata defaultBaseURI_) external",
        "function setIpfsBaseURI(string calldata ipfsBaseURI_) external",
      "function setSpecialURI(string calldata specialURI_) external",
      "function ownerMintSpecial(uint256 count, address to) external",
      "function revealBatch(uint256[] tokenIds) external",
      "function specialBurn(uint256 tokenId) external",
      "function setBatchBurnThreshold(uint256 newThreshold) external",
      
      // Withdraw function
      "function withdraw() external"
    ];

    // ===================== é’±åŒ…è¿æ¥çŠ¶æ€ç®¡ç† =====================
    // Sepoliaé“¾é…ç½®ï¼ˆChain ID: 11155111ï¼‰
    const SEPOLIA_CHAIN = {
        chainId: '0xaa36a7',
        chainName: 'Sepolia Testnet',
        nativeCurrency: {
            name: 'SepoliaETH',
            symbol: 'ETH',
            decimals: 18
        },
        rpcUrls: ['https://rpc.sepolia.org'],
        blockExplorerUrls: ['https://sepolia.etherscan.io/']
    };
    
    // å…¨å±€çŠ¶æ€
    const walletState = {
        isConnected: false,
        account: null,
        chainId: null,
        isCorrectChain: false,
        listeners: []
    };
    
    // ===================== é’±åŒ…è¿æ¥åŠŸèƒ½ =====================
    // å¼ºåˆ¶åˆ‡æ¢åˆ°Sepoliaé“¾
    async function forceSepoliaChain() {
        try {
            const currentChainId = await window.ethereum.request({ 
                method: 'eth_chainId' 
            });
            if (currentChainId !== SEPOLIA_CHAIN.chainId) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: SEPOLIA_CHAIN.chainId }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [SEPOLIA_CHAIN]
                        });
                    } else {
                        throw switchError;
                    }
                }
            }
            return true;
        } catch (error) {
            console.error('Chain switch failed:', error);
            throw error;
        }
    }

    // æ£€æµ‹MetaMaskæ˜¯å¦å®‰è£…
    function checkMetaMask() {
        if (typeof window.ethereum === 'undefined') {
            throw new Error('MetaMask not detected');
        }
        if (!window.ethereum.isMetaMask) {
            throw new Error('Non-MetaMask provider detected');
        }
        return true;
    }

    // è¿æ¥é’±åŒ…æ ¸å¿ƒé€»è¾‘
    async function connectMetaMask() {
        try {
            checkMetaMask();
            await forceSepoliaChain();
            const accounts = await window.ethereum.request({ 
                method: 'eth_requestAccounts' 
            });
            if (accounts.length === 0) {
                throw new Error('No accounts returned');
            }
            const chainId = await window.ethereum.request({ 
                method: 'eth_chainId' 
            });
            
            // è®¾ç½®é’±åŒ…çŠ¶æ€
            walletState.isConnected = true;
            walletState.account = accounts[0];
            walletState.chainId = chainId;
            walletState.isCorrectChain = chainId === SEPOLIA_CHAIN.chainId;
            
            // åˆå§‹åŒ–ethers.js
            provider = new ethers.providers.Web3Provider(window.ethereum);
            signer = provider.getSigner();
            contract = new ethers.Contract(contractAddress, contractABI, signer);
            
            updateWalletUI();
            setupWalletEventListeners();
        } catch (error) {
            console.error('Connection failed:', error);
            alert('Wallet connection failed. Please check your wallet and network.');
        }
    }

    // æ–­å¼€è¿æ¥
    async function disconnectWallet() {
        try {
            await window.ethereum.request({
                method: 'wallet_revokePermissions',
                params: [{ eth_accounts: {} }]
            });
        } catch (error) {
            console.warn('Revoke permissions failed:', error);
        } finally {
            removeAllWalletListeners();
            resetWalletState();
            updateWalletUI();
        }
    }

    // äº‹ä»¶ç›‘å¬è®¾ç½®
    function setupWalletEventListeners() {
        if (!window.ethereum) return;
        removeAllWalletListeners();
        const accountsChanged = (accounts) => {
            if (accounts.length === 0) {
                resetWalletState();
            } else {
                walletState.account = accounts[0];
            }
            updateWalletUI();
        };
        const chainChanged = (chainId) => {
            walletState.chainId = chainId;
            walletState.isCorrectChain = chainId === SEPOLIA_CHAIN.chainId;
            updateWalletUI();
        };
        window.ethereum.on('accountsChanged', accountsChanged);
        window.ethereum.on('chainChanged', chainChanged);
        walletState.listeners.push(['accountsChanged', accountsChanged]);
        walletState.listeners.push(['chainChanged', chainChanged]);
    }
    function removeAllWalletListeners() {
        if (!window.ethereum) return;
        for (const [event, handler] of walletState.listeners) {
            window.ethereum.removeListener(event, handler);
        }
        walletState.listeners = [];
    }
    function resetWalletState() {
        walletState.isConnected = false;
        walletState.account = null;
        walletState.chainId = null;
        walletState.isCorrectChain = false;
        provider = null;
        signer = null;
        contract = null;
    }
    function updateWalletUI() {
        const infoEl = document.getElementById('walletInfo');
        const buttonEl = document.getElementById('connectMetaMaskButton');
        infoEl.className = '';
        if (walletState.isConnected) {
            const chainStatus = walletState.isCorrectChain ? '' : `Wrong Chain (${walletState.chainId})`;
            infoEl.textContent = `${formatAddress(walletState.account)}`;
            if (walletState.isCorrectChain) {
                infoEl.classList.add('connected');
            } else {
                infoEl.classList.add('wrong-chain');
            }
            buttonEl.textContent = 'Disconnect';
            buttonEl.classList.add('disconnect');
            buttonEl.onclick = disconnectWallet;
        } else {
            infoEl.textContent = 'Not connected';
            infoEl.classList.add('disconnected');
            buttonEl.textContent = 'Connect MetaMask';
            buttonEl.classList.remove('disconnect');
            buttonEl.onclick = connectMetaMask;
        }
    }
    function formatAddress(address) {
        return address ? `${address.slice(0, 6)}...${address.slice(-4)}` : '';
    }

    // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ£€æŸ¥é’±åŒ…è¿æ¥çŠ¶æ€
    window.addEventListener('DOMContentLoaded', async function() {
        updateWalletUI();
        if (typeof window.ethereum === 'undefined') return;
        try {
            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
            if (accounts.length > 0) {
                walletState.isConnected = true;
                walletState.account = accounts[0];
                walletState.chainId = chainId;
                walletState.isCorrectChain = chainId === SEPOLIA_CHAIN.chainId;
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                contract = new ethers.Contract(contractAddress, contractABI, signer);
                // æ–°å¢ï¼šé’±åŒ…å·²è¿æ¥æ—¶è‡ªåŠ¨åˆ·æ–°æ‰€æœ‰åŠŸèƒ½åŒº
                await afterWalletConnected();
            }
            updateWalletUI();
        } catch (e) {
            // å¿½ç•¥
        }
    });

    // æ–°å¢ï¼šé’±åŒ…è¿æ¥æˆåŠŸåè‡ªåŠ¨åˆ·æ–°æ‰€æœ‰åŠŸèƒ½åŒº
    async function afterWalletConnected() {
        // æ£€æŸ¥ owner
        isOwner = false;
        try {
            const ownerAddr = await contract.owner();
            if (walletState.account && ownerAddr && walletState.account.toLowerCase() === ownerAddr.toLowerCase()) {
                isOwner = true;
                adminSection.style.display = 'block';
                updateSaleStatus();
                // åŠ è½½åˆçº¦ä½™é¢
                loadContractBalance();
                // æŸ¥è¯¢å½“å‰é˜ˆå€¼
                try {
                    const threshold = await contract.batchBurnThreshold();
                    batchBurnThresholdInput.value = threshold.toString();
                    batchBurnThresholdStatus.innerText = `å½“å‰é˜ˆå€¼: ${threshold}`;
                } catch (e) {
                    batchBurnThresholdStatus.innerText = 'æŸ¥è¯¢é˜ˆå€¼å¤±è´¥';
                }
            } else {
                adminSection.style.display = 'none';
            }
        } catch (e) {
            adminSection.style.display = 'none';
        }
        // mintåŒºã€NFTåŒºç­‰åˆ·æ–°
        saleIsActive = await contract.saleIsActive();
        updateMintUI();
        defaultBaseURIOnChain = await contract.defaultBaseURI();
        setTimeout(loadMyNFTs, 1000);
    }

    // ===================== ç®¡ç†å‘˜å¼€å…³é€»è¾‘ =====================
    async function updateSaleStatus() {
      saleIsActive = await contract.saleIsActive();
      toggleSaleBtn.innerText = saleIsActive ? 'Stop Mint' : 'Start Mint';
      adminStatus.innerText = 'Statusï¼š' + (saleIsActive ? 'Mint Started' : 'Mint Closed');
    }

    toggleSaleBtn.onclick = async function() {
      if (!isOwner) return;
      toggleSaleBtn.disabled = true;
      adminStatus.innerText = 'sending tx...';
      try {
        const tx = await contract.setSaleIsActive(!saleIsActive);
        await tx.wait();
        adminStatus.innerText = 'Mint status updatedï¼Tx: ' + tx.hash;
        updateSaleStatus();
        updateMintUI();
      } catch (err) {
        console.error(err);
        adminStatus.innerText = 'Mint Status update failed';
      }
      toggleSaleBtn.disabled = false;
    };

    // ===================== Mint æŒ‰é’®é€»è¾‘ =====================
    function updateMintUI() {
      mintBtn.disabled = !saleIsActive;
      mintStatus.innerText = saleIsActive ? '' : 'Mint not started yet';
    }

    mintBtn.onclick = async function() {
      if (!contract || !walletState.account) {
        alert('connect wallet first');
        return;
      }
      const count = parseInt(mintCountInput.value);
      if (isNaN(count) || count < 1 || count > 10) {
        alert('Mint amount 1~10');
        return;
      }
      try {
        // æ£€æŸ¥mintå¼€å…³
        saleIsActive = await contract.saleIsActive();
        if (!saleIsActive) {
          mintStatus.innerText = 'Mint not started yet.';
          return;
        }
        // æ£€æŸ¥æ€»é‡
        const total = await contract.totalSupply();
        const max = await contract.MAX_SUPPLY();
        if (total.add(count).gt(max)) {
          mintStatus.innerText = 'Exceeding maximum supply';
          return;
        }
        // è·å–å•ä»·
        const price = await contract.PRICE();
        const totalValue = price.mul(count);
        mintStatus.innerText = 'Initiating mint transaction...';
        // å‘èµ·äº¤æ˜“
        const tx = await contract.mint(count, { value: totalValue });
        await tx.wait();
        mintStatus.innerText = `Mint successfulï¼Tx: ${tx.hash}`;
        setTimeout(loadMyNFTs, 2000);
      } catch (err) {
        console.error(err);
        if (err && err.data && err.data.message) {
          mintStatus.innerText = 'Mint failed: ' + err.data.message;
        } else if (err && err.message) {
          mintStatus.innerText = 'Mint failed: ' + err.message;
        } else {
          mintStatus.innerText = 'Mint failed';
        }
      }
    };

    // ===================== æ–°å¢ï¼šæˆ‘çš„NFTæŸ¥çœ‹å’ŒRevealåŠŸèƒ½ï¼ˆå·²ä¿®å¤ï¼‰ =====================
    // æ‰«æå½“å‰é’±åŒ…æ‰€æœ‰NFT
    async function loadMyNFTs() {
      if (!contract || !walletState.account) {
        nftListDiv.innerText = 'Please connect your wallet first';
        return;
      }
      selectedNFTs.clear();
      try {
        nftListDiv.innerHTML = '<h4>Scanning your NFTs... (this may take a while)</h4>';
        const balance = await contract.balanceOf(walletState.account);
        if (balance.eq(0)) {
            nftListDiv.innerText = 'You do not own any NFTs.';
            return;
        }
        
        // 1. é€šè¿‡æ‰«æTransferäº‹ä»¶ï¼Œæ‰¾åˆ°æ‰€æœ‰æ›¾ç»è½¬ç»™ä½ çš„tokenId
        const transferFilter = contract.filters.Transfer(null, walletState.account);
        const events = await contract.queryFilter(transferFilter, 0, 'latest');
        const potentialTokenIds = [...new Set(events.map(event => event.args.tokenId.toString()))];

        if (potentialTokenIds.length === 0) {
            nftListDiv.innerText = 'No NFTs found in your history.';
            return;
        }

        // 2. éªŒè¯æ‰€æœ‰æƒå¹¶æ˜¾ç¤ºNFT
        nftListDiv.innerHTML = '<h4>Loading your NFT details...</h4>';
        let html = '';
        let ownedCount = 0;
        for (const tokenId of potentialTokenIds.reverse()) { // ä»æœ€æ–°çš„å¼€å§‹æ˜¾ç¤º
            try {
                const currentOwner = await contract.ownerOf(tokenId);
                if (currentOwner.toLowerCase() !== walletState.account.toLowerCase()) {
                    continue; // å¦‚æœå·²è½¬å‡ºï¼Œåˆ™è·³è¿‡
                }
                ownedCount++;
                
                let tokenURI = '';
                let revealed = false;
                let type = 'revealed';
                try {
                    tokenURI = await contract.tokenURI(tokenId);
                    // ä¿®æ­£ï¼šç”¨ normalizeUrl å»é™¤æœ«å°¾æ–œæ åå†æ¯”è¾ƒ
                    function normalizeUrl(url) {
                        return url ? url.replace(/\/+$/, '') : '';
                    }
                    if (tokenURI && defaultBaseURIOnChain && normalizeUrl(tokenURI) !== normalizeUrl(defaultBaseURIOnChain)) {
                        revealed = true;
                    }
                    if (tokenURI && tokenURI.includes('unrevealed.json')) {
                      type = 'unreveal';
                    } else if (tokenURI && tokenURI.includes('special.json')) {
                      type = 'special';
                    }
                    // è°ƒè¯•è¾“å‡º
                    console.log('tokenId', tokenId, 'tokenURI', tokenURI, 'defaultBaseURIOnChain', defaultBaseURIOnChain, 'revealed', revealed);
                } catch (e) {
                    console.error(`è·å–TokenURIå¤±è´¥ for tokenId: ${tokenId}`, e);
                }
                
                html += `<div style='margin-bottom:18px;padding:10px;border:1px solid #eee;display:inline-block;width:150px;vertical-align:top;position:relative;'>`;
                html += `<input type='checkbox' class='nft-checkbox' data-tokenid='${tokenId}' data-type='${type}' style='position:absolute;left:5px;top:5px;z-index:2;' />`;
                html += `<b>Token ID: ${tokenId}</b><br/>`;

                if (tokenURI) {
                    const metadataUrl = tokenURI.startsWith('ipfs://') 
                        ? tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/') 
                        : tokenURI;
                    
                    try {
                        const response = await fetch(metadataUrl);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        const metadata = await response.json();
                        if (metadata.image) {
                            const imageUrl = metadata.image.startsWith('ipfs://') 
                                ? metadata.image.replace('ipfs://', 'https://ipfs.io/ipfs/') 
                                : metadata.image;
                            html += `<img src='${imageUrl}' alt='NFT ${tokenId}' style='width:120px;height:120px;object-fit:cover;margin:8px 0;'/>`;
                        } else {
                            html += `<div style='color:#999;font-size:12px;height:120px;display:flex;align-items:center;'>Image not found</div>`;
                        }
                        // æ˜¾ç¤º name å­—æ®µ
                        html += `<div><b>Name:</b> ${metadata.name ? metadata.name : 'Not found'}</div>`;
                        // æ˜¾ç¤º description å­—æ®µ
                        html += `<div style='font-size:12px;color:#555;'><b>Description:</b> ${metadata.description ? metadata.description : 'Not found'}</div>`;
                        // æ˜¾ç¤º attributes å­—æ®µ
                        if (metadata.attributes && Array.isArray(metadata.attributes) && metadata.attributes.length > 0) {
                            html += `<div style='font-size:12px;'><b>Attributes:</b> `;
                            metadata.attributes.forEach(attr => {
                                html += `<span style='margin-right:8px;'>${attr.trait_type}: ${attr.value}</span>`;
                            });
                            html += `</div>`;
                        } else {
                            html += `<div style='font-size:12px;'><b>Attributes:</b> Not found</div>`;
                        }
                    } catch(e) {
                        html += `<div style="color:red;font-size:12px;height:120px;display:flex;align-items:center;">Failed to load metadata</div>`;
                        html += `<div><b>Name:</b> Not found</div>`;
                        html += `<div style='font-size:12px;color:#555;'><b>Description:</b> Not found</div>`;
                        html += `<div style='font-size:12px;'><b>Attributes:</b> Not found</div>`;
                        console.error(`Failed to fetch metadata from ${metadataUrl}`, e);
                    }
                } else {
                     html += `<div style="color:red;font-size:12px;height:120px;display:flex;align-items:center;">Failed to get Token URI</div>`;
                }

                // æ¸²æŸ“æŒ‰é’®
                if (type === 'special') {
                  html += `<button onclick='specialBurn(${tokenId})'>Special Burn</button>`;
                } else if (type === 'unreveal') {
                  html += `<button onclick='revealNFT(${tokenId})'>Reveal</button>`;
                } else {
                  html += `<button onclick='burnNFT(${tokenId})'>Burn</button>`;
                }
                html += `</div>`;
            } catch(e) {
                console.log(`Skipping token ${tokenId} as ownerOf check failed (possibly burned).`);
            }
        }
        
        if (ownedCount === 0) {
            nftListDiv.innerText = 'You do not own any NFTs.';
        } else {
            nftListDiv.innerHTML = html;
            // ç»‘å®šcheckboxäº‹ä»¶
            document.querySelectorAll('.nft-checkbox').forEach(cb => {
              cb.addEventListener('change', function() {
                const tid = this.getAttribute('data-tokenid');
                if (this.checked) {
                  selectedNFTs.add(tid);
                } else {
                  selectedNFTs.delete(tid);
                }
              });
            });
        }
    } catch (err) {
        console.error("Failed to load NFTs:", err);
        nftListDiv.innerText = 'Error loading NFTs, check console for details.';
    }
}

    // ===================== æ–°å¢ï¼šBurn NFTåŠŸèƒ½ =====================
    window.burnNFT = async function(tokenId) {
        if (!contract) return;
        if (!confirm(`Are you sure you want to burn Token ID: ${tokenId}? This action is irreversible!`)) {
            return;
        }
        
        try {
            const button = event.target;
            button.innerText = '...';
            button.disabled = true;

            const tx = await contract.burn(tokenId);
            await tx.wait();
            alert(`Token ID: ${tokenId} burned successfully! Tx: ${tx.hash}`);
            loadMyNFTs(); // åˆ·æ–°NFTåˆ—è¡¨
        } catch (err) {
            console.error(err);
            alert(`Burn failed: ${err.message}`);
            loadMyNFTs(); // å³ä½¿å¤±è´¥ä¹Ÿåˆ·æ–°
        }
    }

    // Reveal æŒ‰é’®äº‹ä»¶
    window.revealNFT = async function(tokenId) {
      if (!contract) return;
      try {
        const button = event.target;
        button.innerText = '...';
        button.disabled = true;
        
        const tx = await contract.reveal(tokenId);
        await tx.wait();
        alert('Reveal successful! Tx: ' + tx.hash);
        loadMyNFTs(); // åˆ·æ–°
      } catch (err) {
        console.error(err);
        alert('Reveal failed: ' + (err && err.message ? err.message : 'Unknown error'));
        loadMyNFTs(); // å³ä½¿å¤±è´¥ä¹Ÿåˆ·æ–°ä¸€ä¸‹
      }
    }

    // åˆ·æ–°æŒ‰é’®äº‹ä»¶
    refreshNFTBtn.onclick = function() {
      loadMyNFTs();
    }

    // Batch Burn æŒ‰é’®äº‹ä»¶
    batchBurnBtn.onclick = async function() {
      if (!contract || !walletState.account) return;
      if (selectedNFTs.size < 10) {
        alert('Please select at least 10 NFTs to batch burn.');
        return;
      }
      if (!confirm(`Are you sure you want to batch burn these ${selectedNFTs.size} NFTs? This action is irreversible!`)) {
        return;
      }
      try {
        const tokenIds = Array.from(selectedNFTs).map(x => ethers.BigNumber.from(x));
        const tx = await contract.burnBatch(tokenIds);
        await tx.wait();
        alert(`Batch burn successful! Tx: ${tx.hash}`);
        loadMyNFTs();
      } catch (err) {
        console.error(err);
        alert('Batch burn failed: ' + (err && err.message ? err.message : 'Unknown error'));
        loadMyNFTs();
      }
    };

    setBatchBurnThresholdBtn.onclick = async function() {
      if (!isOwner) return;
      const newVal = parseInt(batchBurnThresholdInput.value);
      if (isNaN(newVal) || newVal < 1) {
        batchBurnThresholdStatus.innerText = 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ­£æ•´æ•°';
        return;
      }
      setBatchBurnThresholdBtn.disabled = true;
      batchBurnThresholdStatus.innerText = 'è®¾ç½®ä¸­...';
      try {
        const tx = await contract.setBatchBurnThreshold(newVal);
        await tx.wait();
        batchBurnThresholdStatus.innerText = `è®¾ç½®æˆåŠŸï¼Œå½“å‰é˜ˆå€¼: ${newVal}`;
      } catch (e) {
        batchBurnThresholdStatus.innerText = 'è®¾ç½®å¤±è´¥: ' + (e && e.message ? e.message : 'æœªçŸ¥é”™è¯¯');
      }
      setBatchBurnThresholdBtn.disabled = false;
    };

    // Batch Reveal æŒ‰é’®äº‹ä»¶
    batchRevealBtn.onclick = async function() {
      if (!contract || !walletState.account) return;
      // åªå…è®¸é€‰æ‹©æœªæ­ç¤ºNFT
      const unrevealedTokenIds = [];
      document.querySelectorAll('.nft-checkbox').forEach(cb => {
        if (cb.checked && cb.getAttribute('data-type') === 'unreveal') {
          unrevealedTokenIds.push(cb.getAttribute('data-tokenid'));
        }
      });
      if (unrevealedTokenIds.length === 0) {
        alert('è¯·è‡³å°‘å‹¾é€‰1ä¸ªæœªæ­ç¤ºNFT');
        return;
      }
      if (unrevealedTokenIds.length > 10) {
        alert('ä¸€æ¬¡æœ€å¤šæ‰¹é‡Reveal 10ä¸ªNFT');
        return;
      }
      if (!confirm(`ç¡®å®šè¦æ‰¹é‡Revealè¿™${unrevealedTokenIds.length}ä¸ªNFTå—ï¼Ÿ`)) {
        return;
      }
      batchRevealBtn.disabled = true;
      try {
        const tx = await contract.revealBatch(unrevealedTokenIds);
        await tx.wait();
        alert(`æ‰¹é‡RevealæˆåŠŸï¼Tx: ${tx.hash}`);
        loadMyNFTs();
      } catch (err) {
        console.error(err);
        alert('æ‰¹é‡Revealå¤±è´¥: ' + (err && err.message ? err.message : 'æœªçŸ¥é”™è¯¯'));
        loadMyNFTs();
      }
      batchRevealBtn.disabled = false;
    };

    specialMintBtn.onclick = async function() {
      if (!isOwner) return;
      const count = parseInt(specialMintCount.value);
      let to = specialMintTo.value.trim();
      if (!to) to = walletState.account;
      if (isNaN(count) || count < 1) {
        specialMintStatus.innerText = 'è¯·è¾“å…¥æœ‰æ•ˆæ•°é‡';
        return;
      }
      specialMintBtn.disabled = true;
      specialMintStatus.innerText = 'mintä¸­...';
      try {
        const tx = await contract.ownerMintSpecial(count, to);
        await tx.wait();
        specialMintStatus.innerText = `Special MintæˆåŠŸï¼Tx: ${tx.hash}`;
        setTimeout(loadMyNFTs, 1000);
      } catch (e) {
        specialMintStatus.innerText = 'mintå¤±è´¥: ' + (e && e.message ? e.message : 'æœªçŸ¥é”™è¯¯');
      }
      specialMintBtn.disabled = false;
    };

    // æ–°å¢Special BurnåŠŸèƒ½
    window.specialBurn = async function(tokenId) {
      if (!contract) return;
      if (!confirm(`ç¡®å®šè¦Special Burnç‰¹æ®ŠNFT Token ID: ${tokenId}ï¼Ÿé”€æ¯åå°†å…è´¹è·å¾—2ä¸ªæ™®é€šNFTï¼`)) {
        return;
      }
      try {
        const button = event.target;
        button.innerText = '...';
        button.disabled = true;
        const tx = await contract.specialBurn(tokenId);
        await tx.wait();
        alert(`Special BurnæˆåŠŸï¼Tx: ${tx.hash}`);
        loadMyNFTs();
      } catch (err) {
        console.error(err);
        alert(`Special Burnå¤±è´¥: ${err && err.message ? err.message : 'æœªçŸ¥é”™è¯¯'}`);
        loadMyNFTs();
      }
    }

    setBaseURIBtn.onclick = async function() {
      const uri = baseURIInput.value;
      if (!uri) {
        alert("Please enter Base URI");
        return;
      }
      ownerStatus.innerText = "Setting Base URI...";
      try {
        const tx = await contract.setBaseURI(uri);
        await tx.wait();
        ownerStatus.innerText = `Base URI set successfully! Tx: ${tx.hash}`;
      } catch (error) {
        console.error(error);
        ownerStatus.innerText = "Failed to set Base URI.";
      }
    };

    setIpfsBaseURIBtn.onclick = async function() {
      const uri = ipfsBaseURIInput.value;
      if (!uri) {
        alert("Please enter IPFS Base URI");
        return;
      }
      ownerStatus.innerText = "Setting IPFS Base URI...";
      try {
        const tx = await contract.setIpfsBaseURI(uri);
        await tx.wait();
        ownerStatus.innerText = `IPFS Base URI set successfully! Tx: ${tx.hash}`;
      } catch (error) {
        console.error(error);
        ownerStatus.innerText = "Failed to set IPFS Base URI.";
      }
    };

    setSpecialURIBtn.onclick = async function() {
      const uri = specialURIInput.value;
      if (!uri) {
        alert("Please enter Special URI");
        return;
      }
      specialURIStatus.innerText = "Setting Special URI...";
      try {
        const tx = await contract.setSpecialURI(uri);
        await tx.wait();
        specialURIStatus.innerText = `Special URI set successfully! Tx: ${tx.hash}`;
      } catch (error) {
        console.error(error);
        specialURIStatus.innerText = "Failed to set Special URI.";
      }
    };

    // æ–°å¢åˆçº¦ä½™é¢å’Œææ¬¾åŠŸèƒ½
    async function loadContractBalance() {
      if (!contract || !walletState.account) {
        document.getElementById('contractBalance').innerText = 'åŠ è½½åˆçº¦ä½™é¢å¤±è´¥ï¼Œè¯·å…ˆè¿æ¥é’±åŒ…';
        return;
      }
      try {
        const balance = await provider.getBalance(contractAddress);
        const balanceText = `${ethers.utils.formatEther(balance)} ETH`;
        document.getElementById('contractBalance').innerText = balanceText;
      } catch (err) {
        console.error('åŠ è½½åˆçº¦ä½™é¢å¤±è´¥:', err);
        document.getElementById('contractBalance').innerText = 'åŠ è½½åˆçº¦ä½™é¢å¤±è´¥';
      }
    }

    async function withdrawAllFunds() {
      if (!contract || !walletState.account) {
        alert('è¯·å…ˆè¿æ¥é’±åŒ…');
        return;
      }
      if (!isOwner) {
        alert('åªæœ‰åˆçº¦æ‰€æœ‰è€…æ‰èƒ½æå–èµ„é‡‘');
        return;
      }
      
      let confirmMessage = 'ç¡®å®šè¦æå–æ‰€æœ‰èµ„é‡‘å—ï¼Ÿæ­¤æ“ä½œæ˜¯ä¸å¯é€†çš„ï¼';
      
      if (!confirm(confirmMessage)) {
        return;
      }
      
      try {
        const withdrawStatus = document.getElementById('withdrawStatus');
        withdrawStatus.innerText = 'æ­£åœ¨æå–èµ„é‡‘...';
        const tx = await contract.withdraw();
        withdrawStatus.innerText = 'ç­‰å¾…äº¤æ˜“ç¡®è®¤...';
        await tx.wait();
        
        let successMessage = `âœ… æå–èµ„é‡‘æˆåŠŸï¼Tx: ${tx.hash}`;
        
        withdrawStatus.innerHTML = successMessage.replace(/\n/g, '<br>');
        loadContractBalance(); // åˆ·æ–°ä½™é¢æ˜¾ç¤º
      } catch (err) {
        console.error('æå–èµ„é‡‘å¤±è´¥:', err);
        const withdrawStatus = document.getElementById('withdrawStatus');
        if (err && (err.code === 4001 || (err.message && err.message.toLowerCase().includes('user rejected')))) {
          withdrawStatus.innerText = 'âŒ ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“';
        } else {
          withdrawStatus.innerText = `âŒ æå–èµ„é‡‘å¤±è´¥: ${err.message}`;
        }
      }
    }

    document.getElementById('withdrawBtn').onclick = withdrawAllFunds;
    document.getElementById('refreshBalanceBtn').onclick = loadContractBalance;
  </script>
</body>
</html> 
