<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>Contract Configuration</title>
  <!-- ÂºïÂÖ• ethers.js Â∫ìÔºàÁî®‰∫é‰∏é‰ª•Â§™ÂùäÂêàÁ∫¶‰∫§‰∫íÔºâ -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js" type="application/javascript"></script>
  <style>
    body { 
      font-family: 'Arial', sans-serif; 
      padding: 20px; 
      background-color: #f5f5f5;
      color: #333;
      margin: 0;
    }
    
    h1 {
      color: #000;
      text-align: center;
      margin-bottom: 30px;
      font-weight: 300;
    }
    
    button { 
      font-size: 14px; 
      padding: 8px 16px; 
      margin: 5px 5px 5px 0;
      background-color: #000;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
    }
    
    button:hover {
      background-color: #333;
      transform: translateY(-1px);
    }
    
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    
    input[type="text"], input[type="number"] {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      background-color: #fff;
      color: #333;
      transition: border-color 0.3s ease;
    }
    
    input[type="text"]:focus, input[type="number"]:focus {
      outline: none;
      border-color: #000;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
    }
    
    label {
      font-weight: 600;
      color: #000;
      margin-bottom: 5px;
      display: inline-block;
    }
    
    #mintStatus, #adminStatus, #ownerStatus, #specialURIStatus, #specialMintStatus, #batchBurnThresholdStatus, #withdrawStatus { 
      margin-top: 10px; 
      color: #666;
      font-size: 14px;
    }
    
    .mint-section {
      margin-top: 30px;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      width: 100%;
      box-sizing: border-box;
      margin-left: auto;
      margin-right: auto;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .mint-section input { 
      width: 80px; 
      padding: 8px; 
      font-size: 14px; 
      margin-right: 10px;
    }
    
    .mint-section label { 
      font-weight: 600; 
      margin-right: 10px;
    }
    
    .admin-section {
      margin-top: 30px;
      padding: 20px;
      border: 1px solid #000;
      border-radius: 8px;
      width: 100%; 
      box-sizing: border-box;
      background: #fff;
      margin-left: auto;
      margin-right: auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .admin-section h3 {
      color: #000;
      margin-top: 0;
      margin-bottom: 20px;
      font-weight: 600;
    }
    
    .admin-section hr {
      border: none;
      border-top: 1px solid #eee;
      margin: 20px 0;
    }
    
    /* ====== Èí±ÂåÖËøûÊé•Ê†∑Âºè ====== */
    .wallet-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 5px;
        padding: 15px 20px;
        background-color: #fff;
        border-bottom: 1px solid #eee;
        margin-bottom: 30px;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    .logo-container {
        display: flex;
        align-items: center;
    }
    .logo {
        height: 60px;
        width: 60px;
        object-fit: contain;
    }
    .wallet-controls {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        gap: 10px;
    }
    #walletInfo {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        justify-content: flex-end;
        align-content: center;
        font-family: 'Arial', sans-serif;
        font-size: 14px;
        font-weight: 500;
        padding: 8px 12px;
        min-width: 180px;
        height: 36px;
        display: flex;
        align-items: center;
        text-align: right;
        transition: all 0.3s ease;
        border-radius: 4px;
    }
    #connectMetaMaskButton {
        width: 160px;
        height: 36px;
        background-color: #000;
        border: none;
        font-family: 'Arial', sans-serif;
        font-size: 14px;
        font-weight: 500;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        border-radius: 4px;
    }
    #connectMetaMaskButton:hover {
        background-color: #333;
        transform: translateY(-1px);
    }
    #connectMetaMaskButton:active {
        background-color: #000;
        transform: translateY(0);
    }
    #connectMetaMaskButton.disconnect {
        background-color: #000;
        cursor: pointer;
    }
    #connectMetaMaskButton.disconnect:hover {
        background-color: #333; 
    }
    #walletInfo.connected {
        color: #000;
        background-color: #f0f0f0;
    }
    #walletInfo.wrong-chain {
        color: #d32f2f;
        background-color: #ffebee;
    }
    #walletInfo.disconnected {
        color: #666;
        background-color: #f5f5f5;
    }
    
    /* ÁâπÊÆäÊåâÈíÆÊ†∑Âºè */
    #refreshBalanceBtn {
        background-color: #000;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        margin-left: 10px;
    }
    
    #refreshBalanceBtn:hover {
        background-color: #333;
    }
    
    #withdrawBtn {
        background-color: #000;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
    }
    
    #withdrawBtn:hover {
        background-color: #333;
    }
    
    #batchRevealBtn {
        background-color: #000;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }
    
    #batchRevealBtn:hover {
        background-color: #333;
    }
    
    #batchBurnBtn {
        background-color: #000;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }
    
    #batchBurnBtn:hover {
        background-color: #333;
    }
    
    /* NFT Âç°ÁâáÊ†∑Âºè */
    .nft-card {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        background-color: #fff;
        transition: all 0.3s ease;
    }
    
    .nft-card:hover {
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        transform: translateY(-2px);
    }
    
    .nft-card.selected {
        border-color: #000;
        background-color: #f8f8f8;
    }
    
    .nft-card input[type="checkbox"] {
        margin-right: 10px;
    }
    
    .nft-card button {
        margin: 5px 5px 5px 0;
        font-size: 12px;
        padding: 6px 12px;
    }
  </style>
</head>
<body>
  <!-- Èí±ÂåÖËøûÊé•Âå∫Âüü -->
  <div class="wallet-container">
    <div class="logo-container">
      <img src="toy3logo.png" alt="Logo" class="logo">
    </div>
    <div class="wallet-controls">
      <div id="walletInfo"></div>
      <button id="connectMetaMaskButton">Connect MetaMask</button>
    </div>
  </div>

  <h1>Contract Configuration</h1>
    
  <!-- ÁÆ°ÁêÜÂëòÊéßÂà∂mintÂºÄÂÖ≥Âå∫Ôºà‰ªÖÂêàÁ∫¶OwnerÂèØËßÅÔºâ -->
  <div class="admin-section" id="adminSection" style="display:none;">
    <label>Mint Toggle:</label>
    <button id="toggleSaleBtn">Loading...</button>
    <div id="adminStatus"></div>
    <hr>
    <div>
      <label for="baseURIInput">Base URI (for unrevealed metadata):</label><br>
      <input type="text" id="baseURIInput" placeholder="ipfs://cid_for_unrevealed/">
      <button id="setBaseURIBtn">Set Base URI</button>
    </div>
    <div style="margin-top: 15px;">
      <label for="ipfsBaseURIInput">IPFS Base URI (for revealed metadata):</label><br>
      <input type="text" id="ipfsBaseURIInput" placeholder="ipfs://cid_for_revealed/">
      <button id="setIpfsBaseURIBtn">Set IPFS Base URI</button>
    </div>
    <div style="margin-top: 15px;">
      <label for="specialURIInput">Special URI (for special NFTs):</label><br>
      <input type="text" id="specialURIInput" placeholder="ipfs://cid_for_special/special.json">
      <button id="setSpecialURIBtn">Set Special URI</button>
      <span id="specialURIStatus"></span>
    </div>
    <div id="ownerStatus" style="margin-top: 10px;"></div>
    <hr>
    <div>
      <label for="batchBurnThresholdInput">Batch Burn ÊúÄ‰ΩéÊï∞ÈáèÔºö</label>
      <input type="number" id="batchBurnThresholdInput" min="1" value="10" style="width:80px;">
      <button id="setBatchBurnThresholdBtn">ËÆæÁΩÆ</button>
      <span id="batchBurnThresholdStatus"></span>
    </div>
    <hr>
    <div>
      <label for="specialMintCount">Special Mint Êï∞ÈáèÔºö</label>
      <input type="number" id="specialMintCount" min="1" value="1" style="width:80px;">
      <label for="specialMintTo">Êé•Êî∂Âú∞ÂùÄÔºö</label>
      <input type="text" id="specialMintTo" style="width:260px;" placeholder="ÈªòËÆ§Ëá™Â∑±Âú∞ÂùÄ">
      <button id="specialMintBtn">Special Mint</button>
      <span id="specialMintStatus"></span>
    </div>
    <hr>
    <div>
      <h3>üí∞ ÂêàÁ∫¶ËµÑÈáëÁÆ°ÁêÜ</h3>
      <div style="margin-bottom: 15px;">
        <strong>ÂêàÁ∫¶‰ΩôÈ¢ùÔºö</strong><span id="contractBalance">Âä†ËΩΩ‰∏≠...</span>
        <button id="refreshBalanceBtn">Âà∑Êñ∞</button>
      </div>
      <button id="withdrawBtn">ÊèêÂèñÊâÄÊúâËµÑÈáë</button>
      <div id="withdrawStatus" style="margin-top: 10px;"></div>
    </div>
  </div>

  <!-- Mint NFT ÂäüËÉΩÂå∫ -->
  <div class="mint-section">
    <label for="mintCount">Mint Amount (max 10 per time, unlimited per wallet):</label><br>
    <input type="number" id="mintCount" min="1" max="10" value="1">
    <button id="mintBtn">Mint</button>
    <div id="mintStatus"></div>
  </div>

  <!-- ÊàëÁöÑNFTÊü•ÁúãÂíåRevealÂäüËÉΩÂå∫ -->
  <div class="mint-section" id="myNFTSection" style="margin-top:40px;">
    <h2>My NFTs</h2>
    <button id="refreshNFTBtn" style="margin-bottom:10px;">Refresh</button>
    <button id="batchRevealBtn" style="margin-bottom:10px; margin-left:10px;">Batch Reveal</button>
    <button id="batchBurnBtn" style="margin-bottom:10px; margin-left:10px;">Batch Burn</button>
    <div id="nftList">Loading...</div>
  </div>

  <script>
    // ===================== ÂèòÈáèÂíåDOMÂÖÉÁ¥†Ëé∑Âèñ =====================
    const mintBtn = document.getElementById('mintBtn');       // Mint ÊåâÈíÆ
    const mintCountInput = document.getElementById('mintCount'); // Mint Êï∞ÈáèËæìÂÖ•Ê°Ü
    const mintStatus = document.getElementById('mintStatus'); // Áä∂ÊÄÅÊèêÁ§∫
    const adminSection = document.getElementById('adminSection'); // ÁÆ°ÁêÜÂëòÂå∫
    const toggleSaleBtn = document.getElementById('toggleSaleBtn'); // ÂºÄÂÖ≥ÊåâÈíÆ
    const adminStatus = document.getElementById('adminStatus'); // ÁÆ°ÁêÜÂëòÁä∂ÊÄÅ
    const nftListDiv = document.getElementById('nftList');
    const refreshNFTBtn = document.getElementById('refreshNFTBtn');
    const batchBurnBtn = document.getElementById('batchBurnBtn');
    const batchBurnThresholdInput = document.getElementById('batchBurnThresholdInput');
    const setBatchBurnThresholdBtn = document.getElementById('setBatchBurnThresholdBtn');
    const batchBurnThresholdStatus = document.getElementById('batchBurnThresholdStatus');
    const batchRevealBtn = document.getElementById('batchRevealBtn');
    const specialMintCount = document.getElementById('specialMintCount');
    const specialMintTo = document.getElementById('specialMintTo');
    const specialMintBtn = document.getElementById('specialMintBtn');
    const specialMintStatus = document.getElementById('specialMintStatus');
    const baseURIInput = document.getElementById('baseURIInput');
    const setBaseURIBtn = document.getElementById('setBaseURIBtn');
    const ipfsBaseURIInput = document.getElementById('ipfsBaseURIInput');
    const setIpfsBaseURIBtn = document.getElementById('setIpfsBaseURIBtn');
    const ownerStatus = document.getElementById('ownerStatus');
    const specialURIInput = document.getElementById('specialURIInput');
    const setSpecialURIBtn = document.getElementById('setSpecialURIBtn');
    const specialURIStatus = document.getElementById('specialURIStatus');

    let provider = null;    // ethers.js provider
    let signer = null;      // ethers.js signer
    let contract = null;    // ÂêàÁ∫¶ÂÆû‰æã
    let isOwner = false;    // ÊòØÂê¶‰∏∫ÂêàÁ∫¶Owner
    let saleIsActive = false; // mintÊòØÂê¶ÂºÄÂêØ
    let defaultBaseURIOnChain = null; // Êñ∞Â¢ûÔºöÈìæ‰∏äÊú™Êè≠Á§∫metadataÈìæÊé•
    let selectedNFTs = new Set();

    // ===================== ÂêàÁ∫¶Âú∞ÂùÄÂíåABI =====================
    const contractAddress = "0x0a1d2dee15cc7548a433203992417037afe91c99"; // ÈÉ®ÁΩ≤Âú®SepoliaÁöÑÂêàÁ∫¶Âú∞ÂùÄ
    const contractABI = [
      // Functions for minting and sale toggle
      "function mint(uint256 count) public payable",
      "function saleIsActive() public view returns (bool)",
      "function setSaleIsActive(bool saleIsActive_) external",
      "function owner() public view returns (address)",
      "function PRICE() public view returns (uint256)",
      "function MAX_SUPPLY() public view returns (uint256)",
      "function totalSupply() public view returns (uint256)",

      // Functions for NFT viewing/revealing
      "function balanceOf(address owner) public view returns (uint256)",
      "function tokenURI(uint256 tokenId) public view returns (string)",
      "function ownerOf(uint256 tokenId) public view returns (address)",
      "function reveal(uint256 tokenId) public",
      "function burn(uint256 tokenId) public",
      "function burnBatch(uint256[] tokenIds) external",
      "function defaultBaseURI() public view returns (string)",

      // Event for finding tokens
      "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)",

      // New functions for owner
        "function setBaseURI(string calldata defaultBaseURI_) external",
        "function setIpfsBaseURI(string calldata ipfsBaseURI_) external",
      "function setSpecialURI(string calldata specialURI_) external",
      "function ownerMintSpecial(uint256 count, address to) external",
      "function revealBatch(uint256[] tokenIds) external",
      "function specialBurn(uint256 tokenId) external",
      "function setBatchBurnThreshold(uint256 newThreshold) external",
      
      // Withdraw function
      "function withdraw() external"
    ];

    // ===================== Èí±ÂåÖËøûÊé•Áä∂ÊÄÅÁÆ°ÁêÜ =====================
    // SepoliaÈìæÈÖçÁΩÆÔºàChain ID: 11155111Ôºâ
    const SEPOLIA_CHAIN = {
        chainId: '0xaa36a7',
        chainName: 'Sepolia Testnet',
        nativeCurrency: {
            name: 'SepoliaETH',
            symbol: 'ETH',
            decimals: 18
        },
        rpcUrls: ['https://rpc.sepolia.org'],
        blockExplorerUrls: ['https://sepolia.etherscan.io/']
    };
    
    // ÂÖ®Â±ÄÁä∂ÊÄÅ
    const walletState = {
        isConnected: false,
        account: null,
        chainId: null,
        isCorrectChain: false,
        listeners: []
    };
    
    // ===================== Èí±ÂåÖËøûÊé•ÂäüËÉΩ =====================
    // Âº∫Âà∂ÂàáÊç¢Âà∞SepoliaÈìæ
    async function forceSepoliaChain() {
        try {
            const currentChainId = await window.ethereum.request({ 
                method: 'eth_chainId' 
            });
            if (currentChainId !== SEPOLIA_CHAIN.chainId) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: SEPOLIA_CHAIN.chainId }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [SEPOLIA_CHAIN]
                        });
                    } else {
                        throw switchError;
                    }
                }
            }
            return true;
        } catch (error) {
            console.error('Chain switch failed:', error);
            throw error;
        }
    }

    // Ê£ÄÊµãMetaMaskÊòØÂê¶ÂÆâË£Ö
    function checkMetaMask() {
        if (typeof window.ethereum === 'undefined') {
            throw new Error('MetaMask not detected');
        }
        if (!window.ethereum.isMetaMask) {
            throw new Error('Non-MetaMask provider detected');
        }
        return true;
    }

    // ËøûÊé•Èí±ÂåÖÊ†∏ÂøÉÈÄªËæë
    async function connectMetaMask() {
        try {
            checkMetaMask();
            await forceSepoliaChain();
            const accounts = await window.ethereum.request({ 
                method: 'eth_requestAccounts' 
            });
            if (accounts.length === 0) {
                throw new Error('No accounts returned');
            }
            const chainId = await window.ethereum.request({ 
                method: 'eth_chainId' 
            });
            
            // ËÆæÁΩÆÈí±ÂåÖÁä∂ÊÄÅ
            walletState.isConnected = true;
            walletState.account = accounts[0];
            walletState.chainId = chainId;
            walletState.isCorrectChain = chainId === SEPOLIA_CHAIN.chainId;
            
            // ÂàùÂßãÂåñethers.js
            provider = new ethers.providers.Web3Provider(window.ethereum);
            signer = provider.getSigner();
            contract = new ethers.Contract(contractAddress, contractABI, signer);
            
            updateWalletUI();
            setupWalletEventListeners();
        } catch (error) {
            console.error('Connection failed:', error);
            alert('Wallet connection failed. Please check your wallet and network.');
        }
    }

    // Êñ≠ÂºÄËøûÊé•
    async function disconnectWallet() {
        try {
            await window.ethereum.request({
                method: 'wallet_revokePermissions',
                params: [{ eth_accounts: {} }]
            });
        } catch (error) {
            console.warn('Revoke permissions failed:', error);
        } finally {
            removeAllWalletListeners();
            resetWalletState();
            updateWalletUI();
        }
    }

    // ‰∫ã‰ª∂ÁõëÂê¨ËÆæÁΩÆ
    function setupWalletEventListeners() {
        if (!window.ethereum) return;
        removeAllWalletListeners();
        const accountsChanged = (accounts) => {
            if (accounts.length === 0) {
                resetWalletState();
            } else {
                walletState.account = accounts[0];
            }
            updateWalletUI();
        };
        const chainChanged = (chainId) => {
            walletState.chainId = chainId;
            walletState.isCorrectChain = chainId === SEPOLIA_CHAIN.chainId;
            updateWalletUI();
        };
        window.ethereum.on('accountsChanged', accountsChanged);
        window.ethereum.on('chainChanged', chainChanged);
        walletState.listeners.push(['accountsChanged', accountsChanged]);
        walletState.listeners.push(['chainChanged', chainChanged]);
    }
    function removeAllWalletListeners() {
        if (!window.ethereum) return;
        for (const [event, handler] of walletState.listeners) {
            window.ethereum.removeListener(event, handler);
        }
        walletState.listeners = [];
    }
    function resetWalletState() {
        walletState.isConnected = false;
        walletState.account = null;
        walletState.chainId = null;
        walletState.isCorrectChain = false;
        provider = null;
        signer = null;
        contract = null;
    }
    function updateWalletUI() {
        const infoEl = document.getElementById('walletInfo');
        const buttonEl = document.getElementById('connectMetaMaskButton');
        infoEl.className = '';
        if (walletState.isConnected) {
            const chainStatus = walletState.isCorrectChain ? '' : `Wrong Chain (${walletState.chainId})`;
            infoEl.textContent = `${formatAddress(walletState.account)}`;
            if (walletState.isCorrectChain) {
                infoEl.classList.add('connected');
            } else {
                infoEl.classList.add('wrong-chain');
            }
            buttonEl.textContent = 'Disconnect';
            buttonEl.classList.add('disconnect');
            buttonEl.onclick = disconnectWallet;
        } else {
            infoEl.textContent = 'Not connected';
            infoEl.classList.add('disconnected');
            buttonEl.textContent = 'Connect MetaMask';
            buttonEl.classList.remove('disconnect');
            buttonEl.onclick = connectMetaMask;
        }
    }
    function formatAddress(address) {
        return address ? `${address.slice(0, 6)}...${address.slice(-4)}` : '';
    }

    // È°µÈù¢Âä†ËΩΩÊó∂Ëá™Âä®Ê£ÄÊü•Èí±ÂåÖËøûÊé•Áä∂ÊÄÅ
    window.addEventListener('DOMContentLoaded', async function() {
        updateWalletUI();
        if (typeof window.ethereum === 'undefined') return;
        try {
            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
            if (accounts.length > 0) {
                walletState.isConnected = true;
                walletState.account = accounts[0];
                walletState.chainId = chainId;
                walletState.isCorrectChain = chainId === SEPOLIA_CHAIN.chainId;
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                contract = new ethers.Contract(contractAddress, contractABI, signer);
                // Êñ∞Â¢ûÔºöÈí±ÂåÖÂ∑≤ËøûÊé•Êó∂Ëá™Âä®Âà∑Êñ∞ÊâÄÊúâÂäüËÉΩÂå∫
                await afterWalletConnected();
            }
            updateWalletUI();
        } catch (e) {
            // ÂøΩÁï•
        }
    });

    // Êñ∞Â¢ûÔºöÈí±ÂåÖËøûÊé•ÊàêÂäüÂêéËá™Âä®Âà∑Êñ∞ÊâÄÊúâÂäüËÉΩÂå∫
    async function afterWalletConnected() {
        // Ê£ÄÊü• owner
        isOwner = false;
        try {
            const ownerAddr = await contract.owner();
            if (walletState.account && ownerAddr && walletState.account.toLowerCase() === ownerAddr.toLowerCase()) {
                isOwner = true;
                adminSection.style.display = 'block';
                updateSaleStatus();
                // Âä†ËΩΩÂêàÁ∫¶‰ΩôÈ¢ù
                loadContractBalance();
                // Êü•ËØ¢ÂΩìÂâçÈòàÂÄº
                try {
                    const threshold = await contract.batchBurnThreshold();
                    batchBurnThresholdInput.value = threshold.toString();
                    batchBurnThresholdStatus.innerText = `ÂΩìÂâçÈòàÂÄº: ${threshold}`;
                } catch (e) {
                    batchBurnThresholdStatus.innerText = 'Êü•ËØ¢ÈòàÂÄºÂ§±Ë¥•';
                }
            } else {
                adminSection.style.display = 'none';
            }
        } catch (e) {
            adminSection.style.display = 'none';
        }
        // mintÂå∫„ÄÅNFTÂå∫Á≠âÂà∑Êñ∞
        saleIsActive = await contract.saleIsActive();
        updateMintUI();
        defaultBaseURIOnChain = await contract.defaultBaseURI();
        setTimeout(loadMyNFTs, 1000);
    }

    // ===================== ÁÆ°ÁêÜÂëòÂºÄÂÖ≥ÈÄªËæë =====================
    async function updateSaleStatus() {
      saleIsActive = await contract.saleIsActive();
      toggleSaleBtn.innerText = saleIsActive ? 'Stop Mint' : 'Start Mint';
      adminStatus.innerText = 'StatusÔºö' + (saleIsActive ? 'Mint Started' : 'Mint Closed');
    }

    toggleSaleBtn.onclick = async function() {
      if (!isOwner) return;
      toggleSaleBtn.disabled = true;
      adminStatus.innerText = 'sending tx...';
      try {
        const tx = await contract.setSaleIsActive(!saleIsActive);
        await tx.wait();
        adminStatus.innerText = 'Mint status updatedÔºÅTx: ' + tx.hash;
        updateSaleStatus();
        updateMintUI();
      } catch (err) {
        console.error(err);
        adminStatus.innerText = 'Mint Status update failed';
      }
      toggleSaleBtn.disabled = false;
    };

    // ===================== Mint ÊåâÈíÆÈÄªËæë =====================
    function updateMintUI() {
      mintBtn.disabled = !saleIsActive;
      mintStatus.innerText = saleIsActive ? '' : 'Mint not started yet';
    }

    mintBtn.onclick = async function() {
      if (!contract || !walletState.account) {
        alert('connect wallet first');
        return;
      }
      const count = parseInt(mintCountInput.value);
      if (isNaN(count) || count < 1 || count > 10) {
        alert('Mint amount 1~10');
        return;
      }
      try {
        // Ê£ÄÊü•mintÂºÄÂÖ≥
        saleIsActive = await contract.saleIsActive();
        if (!saleIsActive) {
          mintStatus.innerText = 'Mint not started yet.';
          return;
        }
        // Ê£ÄÊü•ÊÄªÈáè
        const total = await contract.totalSupply();
        const max = await contract.MAX_SUPPLY();
        if (total.add(count).gt(max)) {
          mintStatus.innerText = 'Exceeding maximum supply';
          return;
        }
        // Ëé∑ÂèñÂçï‰ª∑
        const price = await contract.PRICE();
        const totalValue = price.mul(count);
        mintStatus.innerText = 'Initiating mint transaction...';
        // ÂèëËµ∑‰∫§Êòì
        const tx = await contract.mint(count, { value: totalValue });
        await tx.wait();
        mintStatus.innerText = `Mint successfulÔºÅTx: ${tx.hash}`;
        setTimeout(loadMyNFTs, 2000);
      } catch (err) {
        console.error(err);
        if (err && err.data && err.data.message) {
          mintStatus.innerText = 'Mint failed: ' + err.data.message;
        } else if (err && err.message) {
          mintStatus.innerText = 'Mint failed: ' + err.message;
        } else {
          mintStatus.innerText = 'Mint failed';
        }
      }
    };

    // ===================== Êñ∞Â¢ûÔºöÊàëÁöÑNFTÊü•ÁúãÂíåRevealÂäüËÉΩÔºàÂ∑≤‰øÆÂ§çÔºâ =====================
    // Êâ´ÊèèÂΩìÂâçÈí±ÂåÖÊâÄÊúâNFT
    async function loadMyNFTs() {
      if (!contract || !walletState.account) {
        nftListDiv.innerText = 'Please connect your wallet first';
        return;
      }
      selectedNFTs.clear();
      try {
        nftListDiv.innerHTML = '<h4>Scanning your NFTs... (this may take a while)</h4>';
        const balance = await contract.balanceOf(walletState.account);
        if (balance.eq(0)) {
            nftListDiv.innerText = 'You do not own any NFTs.';
            return;
        }
        
        // 1. ÈÄöËøáÊâ´ÊèèTransfer‰∫ã‰ª∂ÔºåÊâæÂà∞ÊâÄÊúâÊõæÁªèËΩ¨Áªô‰Ω†ÁöÑtokenId
        const transferFilter = contract.filters.Transfer(null, walletState.account);
        const events = await contract.queryFilter(transferFilter, 0, 'latest');
        const potentialTokenIds = [...new Set(events.map(event => event.args.tokenId.toString()))];

        if (potentialTokenIds.length === 0) {
            nftListDiv.innerText = 'No NFTs found in your history.';
            return;
        }

        // 2. È™åËØÅÊâÄÊúâÊùÉÂπ∂ÊòæÁ§∫NFT
        nftListDiv.innerHTML = '<h4>Loading your NFT details...</h4>';
        let html = '';
        let ownedCount = 0;
        for (const tokenId of potentialTokenIds.reverse()) { // ‰ªéÊúÄÊñ∞ÁöÑÂºÄÂßãÊòæÁ§∫
            try {
                const currentOwner = await contract.ownerOf(tokenId);
                if (currentOwner.toLowerCase() !== walletState.account.toLowerCase()) {
                    continue; // Â¶ÇÊûúÂ∑≤ËΩ¨Âá∫ÔºåÂàôË∑≥Ëøá
                }
                ownedCount++;
                
                let tokenURI = '';
                let revealed = false;
                let type = 'revealed';
                try {
                    tokenURI = await contract.tokenURI(tokenId);
                    // ‰øÆÊ≠£ÔºöÁî® normalizeUrl ÂéªÈô§Êú´Â∞æÊñúÊù†ÂêéÂÜçÊØîËæÉ
                    function normalizeUrl(url) {
                        return url ? url.replace(/\/+$/, '') : '';
                    }
                    if (tokenURI && defaultBaseURIOnChain && normalizeUrl(tokenURI) !== normalizeUrl(defaultBaseURIOnChain)) {
                        revealed = true;
                    }
                    if (tokenURI && tokenURI.includes('unrevealed.json')) {
                      type = 'unreveal';
                    } else if (tokenURI && tokenURI.includes('special.json')) {
                      type = 'special';
                    }
                    // Ë∞ÉËØïËæìÂá∫
                    console.log('tokenId', tokenId, 'tokenURI', tokenURI, 'defaultBaseURIOnChain', defaultBaseURIOnChain, 'revealed', revealed);
                } catch (e) {
                    console.error(`Ëé∑ÂèñTokenURIÂ§±Ë¥• for tokenId: ${tokenId}`, e);
                }
                
                html += `<div style='margin-bottom:18px;padding:10px;border:1px solid #eee;display:inline-block;width:150px;vertical-align:top;position:relative;'>`;
                html += `<input type='checkbox' class='nft-checkbox' data-tokenid='${tokenId}' data-type='${type}' style='position:absolute;left:5px;top:5px;z-index:2;' />`;
                html += `<b>Token ID: ${tokenId}</b><br/>`;

                if (tokenURI) {
                    const metadataUrl = tokenURI.startsWith('ipfs://') 
                        ? tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/') 
                        : tokenURI;
                    
                    try {
                        const response = await fetch(metadataUrl);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        const metadata = await response.json();
                        if (metadata.image) {
                            const imageUrl = metadata.image.startsWith('ipfs://') 
                                ? metadata.image.replace('ipfs://', 'https://ipfs.io/ipfs/') 
                                : metadata.image;
                            html += `<img src='${imageUrl}' alt='NFT ${tokenId}' style='width:120px;height:120px;object-fit:cover;margin:8px 0;'/>`;
                        } else {
                            html += `<div style='color:#999;font-size:12px;height:120px;display:flex;align-items:center;'>Image not found</div>`;
                        }
                        // ÊòæÁ§∫ name Â≠óÊÆµ
                        html += `<div><b>Name:</b> ${metadata.name ? metadata.name : 'Not found'}</div>`;
                        // ÊòæÁ§∫ description Â≠óÊÆµ
                        html += `<div style='font-size:12px;color:#555;'><b>Description:</b> ${metadata.description ? metadata.description : 'Not found'}</div>`;
                        // ÊòæÁ§∫ attributes Â≠óÊÆµ
                        if (metadata.attributes && Array.isArray(metadata.attributes) && metadata.attributes.length > 0) {
                            html += `<div style='font-size:12px;'><b>Attributes:</b> `;
                            metadata.attributes.forEach(attr => {
                                html += `<span style='margin-right:8px;'>${attr.trait_type}: ${attr.value}</span>`;
                            });
                            html += `</div>`;
                        } else {
                            html += `<div style='font-size:12px;'><b>Attributes:</b> Not found</div>`;
                        }
                    } catch(e) {
                        html += `<div style="color:red;font-size:12px;height:120px;display:flex;align-items:center;">Failed to load metadata</div>`;
                        html += `<div><b>Name:</b> Not found</div>`;
                        html += `<div style='font-size:12px;color:#555;'><b>Description:</b> Not found</div>`;
                        html += `<div style='font-size:12px;'><b>Attributes:</b> Not found</div>`;
                        console.error(`Failed to fetch metadata from ${metadataUrl}`, e);
                    }
                } else {
                     html += `<div style="color:red;font-size:12px;height:120px;display:flex;align-items:center;">Failed to get Token URI</div>`;
                }

                // Ê∏≤ÊüìÊåâÈíÆ
                if (type === 'special') {
                  html += `<button onclick='specialBurn(${tokenId})'>Special Burn</button>`;
                } else if (type === 'unreveal') {
                  html += `<button onclick='revealNFT(${tokenId})'>Reveal</button>`;
                } else {
                  html += `<button onclick='burnNFT(${tokenId})'>Burn</button>`;
                }
                html += `</div>`;
            } catch(e) {
                console.log(`Skipping token ${tokenId} as ownerOf check failed (possibly burned).`);
            }
        }
        
        if (ownedCount === 0) {
            nftListDiv.innerText = 'You do not own any NFTs.';
        } else {
            nftListDiv.innerHTML = html;
            // ÁªëÂÆöcheckbox‰∫ã‰ª∂
            document.querySelectorAll('.nft-checkbox').forEach(cb => {
              cb.addEventListener('change', function() {
                const tid = this.getAttribute('data-tokenid');
                if (this.checked) {
                  selectedNFTs.add(tid);
                } else {
                  selectedNFTs.delete(tid);
                }
              });
            });
        }
    } catch (err) {
        console.error("Failed to load NFTs:", err);
        nftListDiv.innerText = 'Error loading NFTs, check console for details.';
    }
}

    // ===================== Êñ∞Â¢ûÔºöBurn NFTÂäüËÉΩ =====================
    window.burnNFT = async function(tokenId) {
        if (!contract) return;
        if (!confirm(`Are you sure you want to burn Token ID: ${tokenId}? This action is irreversible!`)) {
            return;
        }
        
        try {
            const button = event.target;
            button.innerText = '...';
            button.disabled = true;

            const tx = await contract.burn(tokenId);
            await tx.wait();
            alert(`Token ID: ${tokenId} burned successfully! Tx: ${tx.hash}`);
            loadMyNFTs(); // Âà∑Êñ∞NFTÂàóË°®
        } catch (err) {
            console.error(err);
            alert(`Burn failed: ${err.message}`);
            loadMyNFTs(); // Âç≥‰ΩøÂ§±Ë¥•‰πüÂà∑Êñ∞
        }
    }

    // Reveal ÊåâÈíÆ‰∫ã‰ª∂
    window.revealNFT = async function(tokenId) {
      if (!contract) return;
      try {
        const button = event.target;
        button.innerText = '...';
        button.disabled = true;
        
        const tx = await contract.reveal(tokenId);
        await tx.wait();
        alert('Reveal successful! Tx: ' + tx.hash);
        loadMyNFTs(); // Âà∑Êñ∞
      } catch (err) {
        console.error(err);
        alert('Reveal failed: ' + (err && err.message ? err.message : 'Unknown error'));
        loadMyNFTs(); // Âç≥‰ΩøÂ§±Ë¥•‰πüÂà∑Êñ∞‰∏Ä‰∏ã
      }
    }

    // Âà∑Êñ∞ÊåâÈíÆ‰∫ã‰ª∂
    refreshNFTBtn.onclick = function() {
      loadMyNFTs();
    }

    // Batch Burn ÊåâÈíÆ‰∫ã‰ª∂
    batchBurnBtn.onclick = async function() {
      if (!contract || !walletState.account) return;
      if (selectedNFTs.size < 10) {
        alert('Please select at least 10 NFTs to batch burn.');
        return;
      }
      if (!confirm(`Are you sure you want to batch burn these ${selectedNFTs.size} NFTs? This action is irreversible!`)) {
        return;
      }
      try {
        const tokenIds = Array.from(selectedNFTs).map(x => ethers.BigNumber.from(x));
        const tx = await contract.burnBatch(tokenIds);
        await tx.wait();
        alert(`Batch burn successful! Tx: ${tx.hash}`);
        loadMyNFTs();
      } catch (err) {
        console.error(err);
        alert('Batch burn failed: ' + (err && err.message ? err.message : 'Unknown error'));
        loadMyNFTs();
      }
    };

    setBatchBurnThresholdBtn.onclick = async function() {
      if (!isOwner) return;
      const newVal = parseInt(batchBurnThresholdInput.value);
      if (isNaN(newVal) || newVal < 1) {
        batchBurnThresholdStatus.innerText = 'ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÊ≠£Êï¥Êï∞';
        return;
      }
      setBatchBurnThresholdBtn.disabled = true;
      batchBurnThresholdStatus.innerText = 'ËÆæÁΩÆ‰∏≠...';
      try {
        const tx = await contract.setBatchBurnThreshold(newVal);
        await tx.wait();
        batchBurnThresholdStatus.innerText = `ËÆæÁΩÆÊàêÂäüÔºåÂΩìÂâçÈòàÂÄº: ${newVal}`;
      } catch (e) {
        batchBurnThresholdStatus.innerText = 'ËÆæÁΩÆÂ§±Ë¥•: ' + (e && e.message ? e.message : 'Êú™Áü•ÈîôËØØ');
      }
      setBatchBurnThresholdBtn.disabled = false;
    };

    // Batch Reveal ÊåâÈíÆ‰∫ã‰ª∂
    batchRevealBtn.onclick = async function() {
      if (!contract || !walletState.account) return;
      // Âè™ÂÖÅËÆ∏ÈÄâÊã©Êú™Êè≠Á§∫NFT
      const unrevealedTokenIds = [];
      document.querySelectorAll('.nft-checkbox').forEach(cb => {
        if (cb.checked && cb.getAttribute('data-type') === 'unreveal') {
          unrevealedTokenIds.push(cb.getAttribute('data-tokenid'));
        }
      });
      if (unrevealedTokenIds.length === 0) {
        alert('ËØ∑Ëá≥Â∞ëÂãæÈÄâ1‰∏™Êú™Êè≠Á§∫NFT');
        return;
      }
      if (unrevealedTokenIds.length > 10) {
        alert('‰∏ÄÊ¨°ÊúÄÂ§öÊâπÈáèReveal 10‰∏™NFT');
        return;
      }
      if (!confirm(`Á°ÆÂÆöË¶ÅÊâπÈáèRevealËøô${unrevealedTokenIds.length}‰∏™NFTÂêóÔºü`)) {
        return;
      }
      batchRevealBtn.disabled = true;
      try {
        const tx = await contract.revealBatch(unrevealedTokenIds);
        await tx.wait();
        alert(`ÊâπÈáèRevealÊàêÂäüÔºÅTx: ${tx.hash}`);
        loadMyNFTs();
      } catch (err) {
        console.error(err);
        alert('ÊâπÈáèRevealÂ§±Ë¥•: ' + (err && err.message ? err.message : 'Êú™Áü•ÈîôËØØ'));
        loadMyNFTs();
      }
      batchRevealBtn.disabled = false;
    };

    specialMintBtn.onclick = async function() {
      if (!isOwner) return;
      const count = parseInt(specialMintCount.value);
      let to = specialMintTo.value.trim();
      if (!to) to = walletState.account;
      if (isNaN(count) || count < 1) {
        specialMintStatus.innerText = 'ËØ∑ËæìÂÖ•ÊúâÊïàÊï∞Èáè';
        return;
      }
      specialMintBtn.disabled = true;
      specialMintStatus.innerText = 'mint‰∏≠...';
      try {
        const tx = await contract.ownerMintSpecial(count, to);
        await tx.wait();
        specialMintStatus.innerText = `Special MintÊàêÂäüÔºÅTx: ${tx.hash}`;
        setTimeout(loadMyNFTs, 1000);
      } catch (e) {
        specialMintStatus.innerText = 'mintÂ§±Ë¥•: ' + (e && e.message ? e.message : 'Êú™Áü•ÈîôËØØ');
      }
      specialMintBtn.disabled = false;
    };

    // Êñ∞Â¢ûSpecial BurnÂäüËÉΩ
    window.specialBurn = async function(tokenId) {
      if (!contract) return;
      if (!confirm(`Á°ÆÂÆöË¶ÅSpecial BurnÁâπÊÆäNFT Token ID: ${tokenId}ÔºüÈîÄÊØÅÂêéÂ∞ÜÂÖçË¥πËé∑Âæó2‰∏™ÊôÆÈÄöNFTÔºÅ`)) {
        return;
      }
      try {
        const button = event.target;
        button.innerText = '...';
        button.disabled = true;
        const tx = await contract.specialBurn(tokenId);
        await tx.wait();
        alert(`Special BurnÊàêÂäüÔºÅTx: ${tx.hash}`);
        loadMyNFTs();
      } catch (err) {
        console.error(err);
        alert(`Special BurnÂ§±Ë¥•: ${err && err.message ? err.message : 'Êú™Áü•ÈîôËØØ'}`);
        loadMyNFTs();
      }
    }

    setBaseURIBtn.onclick = async function() {
      const uri = baseURIInput.value;
      if (!uri) {
        alert("Please enter Base URI");
        return;
      }
      ownerStatus.innerText = "Setting Base URI...";
      try {
        const tx = await contract.setBaseURI(uri);
        await tx.wait();
        ownerStatus.innerText = `Base URI set successfully! Tx: ${tx.hash}`;
      } catch (error) {
        console.error(error);
        ownerStatus.innerText = "Failed to set Base URI.";
      }
    };

    setIpfsBaseURIBtn.onclick = async function() {
      const uri = ipfsBaseURIInput.value;
      if (!uri) {
        alert("Please enter IPFS Base URI");
        return;
      }
      ownerStatus.innerText = "Setting IPFS Base URI...";
      try {
        const tx = await contract.setIpfsBaseURI(uri);
        await tx.wait();
        ownerStatus.innerText = `IPFS Base URI set successfully! Tx: ${tx.hash}`;
      } catch (error) {
        console.error(error);
        ownerStatus.innerText = "Failed to set IPFS Base URI.";
      }
    };

    setSpecialURIBtn.onclick = async function() {
      const uri = specialURIInput.value;
      if (!uri) {
        alert("Please enter Special URI");
        return;
      }
      specialURIStatus.innerText = "Setting Special URI...";
      try {
        const tx = await contract.setSpecialURI(uri);
        await tx.wait();
        specialURIStatus.innerText = `Special URI set successfully! Tx: ${tx.hash}`;
      } catch (error) {
        console.error(error);
        specialURIStatus.innerText = "Failed to set Special URI.";
      }
    };

    // Êñ∞Â¢ûÂêàÁ∫¶‰ΩôÈ¢ùÂíåÊèêÊ¨æÂäüËÉΩ
    async function loadContractBalance() {
      if (!contract || !walletState.account) {
        document.getElementById('contractBalance').innerText = 'Âä†ËΩΩÂêàÁ∫¶‰ΩôÈ¢ùÂ§±Ë¥•ÔºåËØ∑ÂÖàËøûÊé•Èí±ÂåÖ';
        return;
      }
      try {
        const balance = await provider.getBalance(contractAddress);
        const balanceText = `${ethers.utils.formatEther(balance)} ETH`;
        document.getElementById('contractBalance').innerText = balanceText;
      } catch (err) {
        console.error('Âä†ËΩΩÂêàÁ∫¶‰ΩôÈ¢ùÂ§±Ë¥•:', err);
        document.getElementById('contractBalance').innerText = 'Âä†ËΩΩÂêàÁ∫¶‰ΩôÈ¢ùÂ§±Ë¥•';
      }
    }

    async function withdrawAllFunds() {
      if (!contract || !walletState.account) {
        alert('ËØ∑ÂÖàËøûÊé•Èí±ÂåÖ');
        return;
      }
      if (!isOwner) {
        alert('Âè™ÊúâÂêàÁ∫¶ÊâÄÊúâËÄÖÊâçËÉΩÊèêÂèñËµÑÈáë');
        return;
      }
      
      let confirmMessage = 'Á°ÆÂÆöË¶ÅÊèêÂèñÊâÄÊúâËµÑÈáëÂêóÔºüÊ≠§Êìç‰ΩúÊòØ‰∏çÂèØÈÄÜÁöÑÔºÅ';
      
      if (!confirm(confirmMessage)) {
        return;
      }
      
      try {
        const withdrawStatus = document.getElementById('withdrawStatus');
        withdrawStatus.innerText = 'Ê≠£Âú®ÊèêÂèñËµÑÈáë...';
        const tx = await contract.withdraw();
        withdrawStatus.innerText = 'Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§...';
        await tx.wait();
        
        let successMessage = `‚úÖ ÊèêÂèñËµÑÈáëÊàêÂäüÔºÅTx: ${tx.hash}`;
        
        withdrawStatus.innerHTML = successMessage.replace(/\n/g, '<br>');
        loadContractBalance(); // Âà∑Êñ∞‰ΩôÈ¢ùÊòæÁ§∫
      } catch (err) {
        console.error('ÊèêÂèñËµÑÈáëÂ§±Ë¥•:', err);
        const withdrawStatus = document.getElementById('withdrawStatus');
        if (err && (err.code === 4001 || (err.message && err.message.toLowerCase().includes('user rejected')))) {
          withdrawStatus.innerText = '‚ùå Áî®Êà∑ÂèñÊ∂à‰∫Ü‰∫§Êòì';
        } else {
          withdrawStatus.innerText = `‚ùå ÊèêÂèñËµÑÈáëÂ§±Ë¥•: ${err.message}`;
        }
      }
    }

    document.getElementById('withdrawBtn').onclick = withdrawAllFunds;
    document.getElementById('refreshBalanceBtn').onclick = loadContractBalance;
  </script>
</body>
</html> 
